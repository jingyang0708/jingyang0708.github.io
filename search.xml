<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面经</title>
      <link href="/2023/03/20/Face-warp/"/>
      <url>/2023/03/20/Face-warp/</url>
      
        <content type="html"><![CDATA[<p>记录一下苦逼的第一次面试，全程20分钟</p><h1 id="绿盟"><a href="#绿盟" class="headerlink" title="绿盟"></a>绿盟</h1><h3 id="ES6新特性都有什么"><a href="#ES6新特性都有什么" class="headerlink" title="ES6新特性都有什么"></a>ES6新特性都有什么</h3><h4 id="1、let-const-关键字声明变量"><a href="#1、let-const-关键字声明变量" class="headerlink" title="1、let const 关键字声明变量"></a>1、let const 关键字声明变量</h4><p>ES6新增了两个声明变量的关键字：let和const</p><h4 id="2、symbol（基本数据类型）"><a href="#2、symbol（基本数据类型）" class="headerlink" title="2、symbol（基本数据类型）"></a>2、symbol（基本数据类型）</h4><p>ES6引入的一个新的数据类型，用于表示一个独一无二的值，不能与其他数据进行运算</p><h4 id="3、模板字符串"><a href="#3、模板字符串" class="headerlink" title="3、模板字符串"></a>3、模板字符串</h4><h4 id="4、解构赋值"><a href="#4、解构赋值" class="headerlink" title="4、解构赋值"></a>4、解构赋值</h4><p>解构赋值是对赋值运算符的扩展。它是针对是组合对象进行模式匹配，然后对其中的变量进行赋值。<br>字符串以及ES6新增的Map和Set都可以使用解构表达式</p><h5 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h5><h5 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h5><h4 id="5、对象方面"><a href="#5、对象方面" class="headerlink" title="5、对象方面"></a>5、对象方面</h4><p>Map和Set属于ES6新增加的对象</p><h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><p>Map用于保存键值对，相当于字典</p><h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><p>Ser可以理解为集合对象，类似与数组，不过她的每一个元素都是唯一的<br>【键，键】的形式，利用Set对象的唯一性特点，可以实现数组去重</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">let</span> mySet=<span class="keyword">new</span> <span class="title class_">Set</span>(arr)</span><br><span class="line"><span class="keyword">let</span> newArr=<span class="title class_">Array</span>.<span class="title function_">from</span>(mySet)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newArr)  <span class="comment">//[1,2,3,4,5,6]</span></span><br></pre></td></tr></table></figure><h5 id="数组新增的方法"><a href="#数组新增的方法" class="headerlink" title="数组新增的方法"></a>数组新增的方法</h5><p> 1、Array.from()<br>内置对象Array的方法，实力数组不能调用，可以将可迭代对象转换为新的数组，可以接受三个参数<br>第一个参数：表示将要被转换的可迭代对象（如果只有一个参数就是把参数转变为数组）<br>第二个参数：是一个回调函数，将对每一个数组元素调用这个回调函数，然后将新的值返回到一个新数组里面。<br>第三个参数：是回调函数内this的指向<br> 2、includes()方法<br>查看数组里面是否有这个元素，有就返回true，没有就返回false<br> 3、map() filter()<br>都可以遍历数组<br>map()方法：要利用原数组金国运算后的数组，或者从给某个对象数组中拿到某个属性<br>fliter()方法：过滤数组，将符合条件的筛选出来成为一个新数组，新数组不会影响就数组<br> 4、forEach()<br>循环遍历数组的每一项<br>5、find()<br>查找数组中符合条件的第一个元素，<br>6、some()  every()<br>some()方法：找到一个符合条件的就返回true，所有的都不符合就返回false<br>every()方法：数组所有值都符合条件才返回true，有一个不符合就返回false<br>indexOf() 判断数组中是否有这个元素，字符串中第一次出现的位置.如果有就返回当前元素的索引值，如果没有就返回-1<br>7、Array.of()是ES6新增的用于创建数组的方法。of把传入的参数当做数组元素，形成新的数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="title class_">Array</span>.<span class="title function_">of</span>(<span class="number">1</span>,<span class="string">&#x27;2&#x27;</span>,[<span class="number">3</span>],&#123;&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);   <span class="comment">//[1,&#x27;2&#x27;,[3],&#123;&#125;]</span></span><br></pre></td></tr></table></figure><h5 id="对象的新增方法"><a href="#对象的新增方法" class="headerlink" title="对象的新增方法"></a>对象的新增方法</h5><p>Object.is()用来判断两个值是否为同一个值，返回一个布尔类型的值<br>Object.assign()<br>用于浅拷贝对象可枚举属性到目标对象<br>可以用来合并对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">onst obj1 = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj3 = &#123; <span class="attr">a</span>:<span class="number">5</span> , <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"><span class="comment">//对象合并，把后面对像合并到第一个对象，对象里相同的属性会覆盖</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(obj1, obj2, obj3);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1); <span class="comment">// &#123; a: 5, b: 2 , c:3&#125;</span></span><br></pre></td></tr></table></figure><h4 id="6、函数"><a href="#6、函数" class="headerlink" title="6、函数"></a>6、函数</h4><h5 id="1、参数默认值"><a href="#1、参数默认值" class="headerlink" title="1、参数默认值"></a>1、参数默认值</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a=<span class="number">1</span>,b=<span class="number">2</span></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">add</span>() <span class="comment">//3</span></span><br><span class="line"><span class="title function_">add</span>(<span class="number">2</span>) <span class="comment">//4 这个就相当于给a重新赋值</span></span><br><span class="line"><span class="title function_">add</span>(<span class="number">3</span>,<span class="number">4</span>) <span class="comment">//7 就相当于给a,b都赋了新的值</span></span><br></pre></td></tr></table></figure><h5 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h5><p>箭头函数内部没有arguments，也没有prototype属性，所以不能用new关键字调用箭头函数<br>箭头函数和普通函数做大的浦北就是箭头函数的this永远指向上下文的this</p><h5 id="class类"><a href="#class类" class="headerlink" title="class类"></a>class类</h5><p>可以用calss定义类，不过他的本质还是一个函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">teacher</span>&#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line">子<span class="keyword">extends</span>父 <span class="comment">//实现继承 ，可以继承父类的属性和方法</span></span><br><span class="line"><span class="comment">// super(&#x27;属性名&#x27;) 继承父类的属性</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><h4 id="7、扩展运算符…"><a href="#7、扩展运算符…" class="headerlink" title="7、扩展运算符…"></a>7、扩展运算符…</h4><p>可在函数调用&#x2F;数组构造时, 将数组表达式或者string在语法层面展开； 还以在构造对象时, 将对象表达式按key-value的方式展开</p><h5 id="数组方面"><a href="#数组方面" class="headerlink" title="数组方面"></a>数组方面</h5><p>1、构建数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(...[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>,...[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],<span class="number">5</span>)</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([<span class="number">1</span>,...[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],<span class="number">5</span>])</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><p>2、数组拷贝（浅拷贝）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> arr2 = [...arr]; <span class="comment">// [1, 2, 3]</span></span><br><span class="line">arr2.<span class="title function_">push</span>(<span class="number">4</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr2); <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组含空位</span></span><br><span class="line"><span class="keyword">let</span> arr3 = [<span class="number">1</span>, , <span class="number">3</span>],</span><br><span class="line">    arr4 = [...arr3];</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr4); <span class="comment">// [1, undefined, 3]</span></span><br></pre></td></tr></table></figure><p>3、合并数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> arr3 = [...arr1, ...arr2];<span class="comment">// 将 arr2 中所有元素附加到 arr1 后面并返回</span></span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line"><span class="keyword">var</span> arr4 = arr1.<span class="title function_">concat</span>(arr2);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr3,arr4) <span class="comment">// [0,1,2,3,4,5] [0,1,2,3,4,5] </span></span><br></pre></td></tr></table></figure><h5 id="对象方面"><a href="#对象方面" class="headerlink" title="对象方面"></a>对象方面</h5><p> 扩展运算符（…）用于取出 参数对象 所有 可遍历属性 然后拷贝到当前对象<br>1、拷贝对象<br>当数据类型是简单数据类型：number  string boolean时，是深拷贝，当数据类型是复杂数据类型：array,object是浅拷贝（只拷贝一层）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;静香&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">sex</span>: <span class="string">&#x27;女&#x27;</span>,</span><br><span class="line">    <span class="attr">sing</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;唱歌&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123; ...obj &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj1) <span class="comment">//&#123;name: &#x27;静香&#x27;, age: 18, sex: &#x27;女&#x27;, sing: ƒ&#125;</span></span><br></pre></td></tr></table></figure><p>2、合并对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age = &#123;<span class="attr">age</span>: <span class="number">15</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> name = &#123;<span class="attr">name</span>: <span class="string">&quot;Amy&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> person = &#123;...age, ...name&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person);  <span class="comment">// &#123;age: 15, name: &quot;Amy&quot;&#125;</span></span><br></pre></td></tr></table></figure><p>扩展运算符后面是空对象、null、undefined，没有任何效果也不会报错</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//空对象</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;...&#123;&#125;, <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);  <span class="comment">//&#123;a: 1, b: 2&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// null 、 undefined</span></span><br><span class="line"><span class="keyword">let</span> b = &#123;...<span class="literal">null</span>, ...<span class="literal">undefined</span>, <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b);  <span class="comment">//&#123;a: 1, b: 2&#125;</span></span><br></pre></td></tr></table></figure><h6 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h6><p>函数调用中，扩展运算符（…）将一个数组，变为参数序列</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">x, y, z</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y + z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//不使用延展操作符</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sum.<span class="title function_">apply</span>(<span class="literal">null</span>, numbers));</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用延展操作符</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(...numbers)); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure><p>扩展运算符与的函数参数可以结合使用，非常灵活：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">x,y,z,v,w,u</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x,y,z,v,w,u)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>];</span><br><span class="line"><span class="title function_">f</span>(-<span class="number">1</span>,...args,<span class="number">2</span>,...[<span class="number">3</span>]); <span class="comment">// -1, 0, 1, 5, 2 ,3</span></span><br></pre></td></tr></table></figure><h4 id="8、模块的导入和导出"><a href="#8、模块的导入和导出" class="headerlink" title="8、模块的导入和导出"></a>8、模块的导入和导出</h4><p>1、导入<br>ES6使用关键字 import 导入模块（文件），有两种常用的方式：<br>import ‘模块名称’ from ‘路径’；<br>import  ‘路径’<br>2、导出<br>ES6 通过 export 和export default 导出模块。<br>与 export 相比，export default 有以下几点不同：首先，在同一个模块中，export default 只允许向外暴露一次成员；然后，这种方式可以使用任意的名称接收，不像 export 那样有严格的要求；最后，export 和 export default 可以在同一模块中同时存在。</p><h4 id="9、异步机制"><a href="#9、异步机制" class="headerlink" title="9、异步机制"></a>9、异步机制</h4><p>Promise<br>Generator 迭代器</p><h3 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="headerlink" title="箭头函数和普通函数的区别"></a>箭头函数和普通函数的区别</h3><p>知道promise吗<br>var const let</p><h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p>浅拷贝：就是只靠拷贝一层<br>深拷贝：是拷贝整个结构，拷贝之后指向的不是同一个地址（复杂数据类型）<br>深拷贝就是相对于浅拷贝而言的，最主要的差异体现在引用类型上，从本质上将就是浅拷贝只简简单单的把栈中的引用地址拷贝了一份，所以当修改新拷贝出来的值的时候，被拷贝的对象也会被修改掉；而深拷贝就是会在堆中为新对象建立空间，所以拷贝的对象就不会被修改了。</p><h4 id="怎样实现一个深拷贝"><a href="#怎样实现一个深拷贝" class="headerlink" title="怎样实现一个深拷贝"></a>怎样实现一个深拷贝</h4><h3 id="数组去重-set的具体用法"><a href="#数组去重-set的具体用法" class="headerlink" title="数组去重 set的具体用法"></a>数组去重 set的具体用法</h3><p>怎么解决跨域<br>vue中子组件和子组件怎么进行通信<br>vuex<br>vue是怎么实现一个异步请求的<br>扩展运算符的作用</p><h1 id="百胜"><a href="#百胜" class="headerlink" title="百胜"></a>百胜</h1><h2 id="笔试"><a href="#笔试" class="headerlink" title="笔试"></a>笔试</h2><h3 id="尽可能的可出更多的计算机网络协议，然后用一句话说明其作用"><a href="#尽可能的可出更多的计算机网络协议，然后用一句话说明其作用" class="headerlink" title="尽可能的可出更多的计算机网络协议，然后用一句话说明其作用"></a>尽可能的可出更多的计算机网络协议，然后用一句话说明其作用</h3><h4 id="数据链路层的协议"><a href="#数据链路层的协议" class="headerlink" title="数据链路层的协议"></a>数据链路层的协议</h4><p>1、点对点协议ppp<br>2、CSMA&#x2F;CD协议</p><h4 id="网络层协议"><a href="#网络层协议" class="headerlink" title="网络层协议"></a>网络层协议</h4><p>1、ARP地址解析协议<br>2、ICMP网络报文控制协议<br>3、RIP路由信息协议<br>4、OSPF协议</p><h4 id="运输层协议"><a href="#运输层协议" class="headerlink" title="运输层协议"></a>运输层协议</h4><p>1、TCP&#x2F;IP协议<br>2、UDP协议</p><h4 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h4><p>1、域名系统DNS<br>2、HTTP超文本传输协议<br>3、FTP文件传输协议<br>4、SMTP简单邮件传输协议<br>作用：为网络中的数据交换而建立的规则、标准或约定。<br>网络协议三要素：语义、语法、时序</p><h3 id="描述http协议的规范，然后写出更多的状态码"><a href="#描述http协议的规范，然后写出更多的状态码" class="headerlink" title="描述http协议的规范，然后写出更多的状态码"></a>描述http协议的规范，然后写出更多的状态码</h3><p>http：超文本传输协议，是一种基于请求和响应的，无状态的，应用层的协议，是基于TCP&#x2F;IP建立连接的，信息是以明文传输的。<br>是网络中计算机与计算机之间通过网络进行数据传输的一种规范。<br>http协议采用了请求和响应模型，客户端向服务器发送一个请求，请求头包括请求的方法、URL、协议版本以及包含请求修饰符、客户信息和内容的类似于MIME的消息结构。服务器以一个状态作为响应，相应的内容包含消息的协议版本，成功或者失败的编码加上服务器信息、实体元信息以及可能的实体内容。<br>1xx 一些提示信息<br>2xx 成功<br>200 OK:请求被成功处理并返回<br>204 No Content:请求成功了，但是没有资源可以返回<br>206 Patial Content:客户端进行了范围请求，并且服务器成功执行了这部分GET请求，响应报文中包含由Content-Range指定范围的实体内容<br>3xx 重定向<br>301 Moved Permanently:永久性重定向，白哦是请求的资源被分配了新的url地址，之后应该使用新的地址<br>302 Found:临时重定向，白哦是请求的资源被分配了新的url地址，并且希望访问的时候使用新的url地址<br>303 Not Modified:表示客户端发送附带条件（是指采用Get方法的请求报文中包含if-Match,if-Modified-Since,if-Unmodiified-Sincee…中的任何一首部）请求的报文时，服务器允许访问资源，但是请求为满足条件的情况下返回该状态码<br>307 Temporary Redirect:临时重定向，与303有着相同的含义，307会遵照浏览器标准不会从post变成get<br>4xx 客户端错误<br>400 Bad Request：表示请求报文中存在语法错误<br>401 Unauthorized:未经许可，需要通过http认证<br>403 Forbidden:服务器拒绝访问（没有访问权限）<br>404 Not Found：没有资源<br>5xx 服务器错误<br>500 Inter Sever Error：白哦是服务器在执行的时候发生了错误<br>503 Sever Unavailable:表示服务器暂时处于超负荷或正在进行停机维护，无法处理请求</p><p>有哪些内部排序的方法，写出时间复杂度</p><h3 id="描述一个网页从输入网址到页面加载完成的全过程"><a href="#描述一个网页从输入网址到页面加载完成的全过程" class="headerlink" title="描述一个网页从输入网址到页面加载完成的全过程"></a>描述一个网页从输入网址到页面加载完成的全过程</h3><p>DNS解析域名，从url中解析出ip地址，拿着这个ip地址找服务器<br>与服务器建立tcp连接（三次握手）<br>发送http请求<br>服务器收到请求之后响应，返回数据<br>浏览器渲染页面：客户端把解析出来的html内容渲染出来：浏览器通过解析html标签生成DOM树，解析css标签生成css规则树，然后通过DOM树和CSS规则树生成渲染树。js引擎解析js代码<br>关闭tcp连接（四次挥手）</p><p>css水平垂直居中的方法<br>三栏布局的方法（左右固定，中间自适应）<br>js中都有哪些数据类型<br>数组去重<br>过滤数组，得到数组中大于10的数，然后将这些数据乘以2</p><h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><p>自我介绍</p><h3 id="http和https有哪些不同"><a href="#http和https有哪些不同" class="headerlink" title="http和https有哪些不同"></a>http和https有哪些不同</h3><p>1、http超文本传输协议，是基于请求和响应的，无状态的，应用层的传输协议，是明文传输的，是基于TCP&#x2F;IP进行传输的。https是有安全性SSL加密传输协议。<br>2、https需要CA认证。因为免费的很少，所以一般需要花钱。<br>3、他们两个的连接方式不同，用的端口号也不同，http连接服务器的端口号是80,https连接服务器用的端口号是443。<br>4、http的连接很简单，它是无状态的；https协议是由SSL+http构建的可进行加密传输、身份验证的网络协议，比http更加的安全。</p><h3 id="v-if和v-show的不同"><a href="#v-if和v-show的不同" class="headerlink" title="v-if和v-show的不同"></a>v-if和v-show的不同</h3><p>v-if和v-show都可以用来控制元素的显示与隐藏<br>v-show:元素始终被渲染到html中，他只是简单的控制元素的显示与隐藏，底层原理是修改css里面的display属性，<br>v-if：本质是通过控制DOM元素的显示与隐藏<br>v-if需要频繁的操作DOM元素，有更高的切换消耗，v-show只是修改元素的css属性，有更高的初始渲染消耗，如果需要频繁的切换，建议使用v-show比较好，如果不太频繁的的话，使用v-if比较好。</p><h3 id="cookie的session的不同"><a href="#cookie的session的不同" class="headerlink" title="cookie的session的不同"></a>cookie的session的不同</h3><p>cookie是属于session对象的一种<br>1、存取位置不同<br>cookie存储在客户端，session存储在服务器<br>2、存取方式不同<br>cookie只能保存ASCII字符串，假如需要存取Unicode字符或者二进制数据，需要先进行编码。<br>session中能够存取任何数据类型。<br>3、安全性不同<br>cookie存储在浏览器中对客户端是可见的，客户端的一些程序可能会窥探、复制以至西域该cookie中的内容<br>session存储在服务器中，对客户端是透明的，不存在敏感信息泄露的风险。<br>4、session占用服务器的资源，session过多，或增加服务器的压力。<br>5、单个cookie保存的数据不能超过4KB，很多浏览器都限制一个站点最多保存20个cookie，session是没有大小限制的，他和服务器的大小有关</p><h3 id="cookie存在哪里"><a href="#cookie存在哪里" class="headerlink" title="cookie存在哪里"></a>cookie存在哪里</h3><p>http是一个基于请求和响应，无状态的，应用层协议。<br>无状态是指：服务器不知道用户上一次做了什么，数据包的发送、传输和接受都是独立的。无连接：是指通信双方都不长久的维持对方的任何消息。<br>cookie：是网站为了辨别用户身份，存储在本地终端上的数据，cookie是由服务器生成的，发送给浏览器的，cookie是存储在客户端，按照客户端存储的位置可以分为：内容cookie和硬盘cookie.<br>内存cookie是由浏览器维护，保存在内存中，浏览器关闭后就消失，存在的时间是短暂的。<br>硬盘cookie是保存在硬盘中，有一个过期的时间，除非用户手动清理或到了过期的时间，cookie才能被消，不然他就会一直存在</p><h3 id="localStorage和sessionStorage的不同"><a href="#localStorage和sessionStorage的不同" class="headerlink" title="localStorage和sessionStorage的不同"></a>localStorage和sessionStorage的不同</h3><p>1、localStorage存放在硬盘中，sessionStorage存放在内存中<br>2、localStorage生命周期是永久的，除非主动清除，否则这些信息永远有效。<br>    sessionStorage生命周期是临时的，当关闭当前页面或标签的时候，就会失效。<br>3、localStorage可以跨页面使用，sessionStorage只能在当前页面使用。<br>他们两个都只能存储字符串，存储的数据大小都是5MB<br>localStorge本地存储：生命周期是永久的，除非主动清除，否则这些信息永远有效。存放的数据大小一般是5MB,而且他仅仅存放在浏览器中，不参与和服务器的通信。<br>sessionStorge会话存储：当浏览器关闭后，会话存储就会被清除，他只在当前会话中有效。存放的数据大小一般是5MB,而且他仅仅存放在浏览器中，不参与和服务器的通信。</p><h3 id="以3开头的状态码是什么意思"><a href="#以3开头的状态码是什么意思" class="headerlink" title="以3开头的状态码是什么意思"></a>以3开头的状态码是什么意思</h3><p>1xx 信息提示<br>2xx 成功<br>3xx 重定向<br>4xx 客户端错误<br>5xx 服务器错误</p><h3 id="tcp和udp"><a href="#tcp和udp" class="headerlink" title="tcp和udp"></a>tcp和udp</h3><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>传输控制协议（TCP,Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的传输层通信协议</p><h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p>Internet支持的一个无连接的传输协议，该协议称为用户数据报协议（UDP,User Dategram Protocol）。UDP为应用程序提供了一种无需链接就可以发送封装IP数据包的方法。</p><h4 id="tcp和udp的区别"><a href="#tcp和udp的区别" class="headerlink" title="tcp和udp的区别"></a>tcp和udp的区别</h4><p>1、TCP是面向连接的，通过三次握手建立连接，四次挥手断开连接；UDP是面向无连接的，即发送数据不需要建立连接，这种方式为UDP带来了高效的传输效率，但也导致无法确保数据的成功发送。<br>2、TCP是可靠的传输方式。通过TCP连接方式传输数据，TCP通过超时重传、数据校验等方式来确保数据无差错、不丢失、不重复，并且按序到达。而UDP由于无需连接的原因，将会以最大速度进行传输，但不保证可靠交付，也就是会出现数据丢失、重复等等的问题。<br>3、TCP是面向字节流的，实际上是TCP把数据看成一串无结构的字节流，由于链接的问题，当网络出现波动的时候，连接可能出现响应的问题。UDP是面向报文的，UDP么有拥塞控制，因此网络堵塞不会使源主机的发送速率下降。<br>4、每一条TCP连接只能是点到点，而UDP不建立连接，因此可以一对一，一对多，多对多的进行交互通信，也就是同时可以接受多个人的包。<br>5、TCP需要建立连接，首部开销20个字节，比8个字节的UDP显得比较大<br>6、TCP的逻辑通信信道是双全工的可靠通道，UDP则是不可靠信道。</p><h3 id="一个url有几部分组成"><a href="#一个url有几部分组成" class="headerlink" title="一个url有几部分组成"></a>一个url有几部分组成</h3><p><a href="http://www.baidu.com:8080/news/index.asp?boardID=1&amp;ID=1234&amp;&amp;page=1#name">http://www.baidu.com:8080/news/index.asp?boardID=1&amp;ID=1234&amp;&amp;page=1#name</a><br>1、协议：http<br>2、域名：<a href="http://www.baidu.com/">www.baidu.com</a><br>3、端口号：8080，如果省略http的是80端口，https的是443端口<br>4、虚拟目录部分：从域名后的&#x2F;开始到最后一个&#x2F;结束<br>5、文件名部分：从最后一个&#x2F;开始，到#结束<br>6、参数部分：从？开始到#结束<br>7、锚部分：从#开始到结束</p><p>项目上的问题<br>token怎么实现<br>看简历上写了组件化，那说一下，封装了分页器和轮播图，分页器的实现</p><h3 id="跨域怎么解决，那部署上线之后呢"><a href="#跨域怎么解决，那部署上线之后呢" class="headerlink" title="跨域怎么解决，那部署上线之后呢"></a>跨域怎么解决，那部署上线之后呢</h3><p>跨域：就是浏览器基于同源策略的一种安全策略<br>当请求的url的协议名、主机、端口号和当前的url有一个不同就会产生跨域</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h5><p>原理：就是客户端利用script标签的src属性，去请求一个接口，因为src属性不受跨域的影响，服务端响应一个字符串<br>     客户端接收到字符串，然后把他当作js代码运行</p><h5 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h5><p>跨域资源共享<br>前端啥都不用做<br>后端需要加一个响应头（通过给服务器添加一个响应头来实现），或者使用第三方模块cors</p><h5 id="proxy代理跨域"><a href="#proxy代理跨域" class="headerlink" title="proxy代理跨域"></a>proxy代理跨域</h5><p>在vue.config.js文案金中配置devServer</p><h5 id="nginx反向代理"><a href="#nginx反向代理" class="headerlink" title="nginx反向代理"></a>nginx反向代理</h5><p>在Nginx文件里的html文件夹下，放置项目<br>在conf文件夹下，修改配置文件：跨域，全局变量等<br>默认首页，错误页面，代理地址（解决跨域）<br>搜索框怎么实现的</p><h3 id="vuex是什么"><a href="#vuex是什么" class="headerlink" title="vuex是什么"></a>vuex是什么</h3><p>vuex就是vue的一个状态管理模式，相当于一个仓库，里面放着一些可以共享的数据，可以在任意组件间进行通信<br>五大属性<br>state:用来存储数据<br>mutations：用来修改state中的数据<br>actions：可以进行一些异步操作，发请求…  dispatch(‘异步操作名称’,要带的数据)  commit() 用于提交mutations<br>getters:相当于计算属性<br>modules：vuex的模块化</p><h3 id="get和post请求的不同"><a href="#get和post请求的不同" class="headerlink" title="get和post请求的不同"></a>get和post请求的不同</h3><p>1、url可见性<br>get:url参数可见，post：url参数不可见<br>2、数据传输上<br>get:通过拼接url进行传递参数<br>post:通过body体传递参数<br>3、缓存性<br>get请求是可以缓存的，post请求不可以缓存<br>4、后退页面的反应<br>get请求页面后退时，不产生影响<br>post请求页面后退时，会重新提交请求<br>5、传输的数据大小<br>get一般传输的数据大小不超过2k-4k<br>post请求传输的数据大小根据php.ini配置文件设定，也可以无限大<br>6、安全性<br>原则上post肯定要比get请求安全，毕竟传输参数时url不可见，但是有人闲的没事会抓包，所以也没啥区别<br>7、数据包<br>简单来说，get产生一个TCP数据包，post生成两个TCP数据包，对于get方式的请求，浏览器会把http header和data一并发送出去，然后服务器响应200（返回数据）；对于post来说，浏览器会先发送header,服务器响应100 continue,浏览器在发送data,服务器响应200（返回数据）</p><h3 id="http请求"><a href="#http请求" class="headerlink" title="http请求"></a>http请求</h3><h4 id="get请求"><a href="#get请求" class="headerlink" title="get请求"></a>get请求</h4><p>get：可以理解为取的意思，只是用来获取数据，不对服务器的数据做任何的修改<br>get请求会把请求的参数附加在url上，这样是不安全的，在处理敏感数据的时候不用，或者对参数做加密处理，<br>get请求其实本身http协议并没有限制他url的大小，但是不同浏览器对其有不同大小长度的限制</p><h4 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h4><p>put请求可以理解为贴，数据发送到服务器以创建或更新资源，侧重于更新资源，对应updata操作<br>post的请求的请求参数都是请求body中的</p><h4 id="put请求"><a href="#put请求" class="headerlink" title="put请求"></a>put请求</h4><p>put请求：可以理解为放<br>数据发送到服务器以后就创建或更新资源，侧重于创建资源，对应insert操作</p><h4 id="delete请求"><a href="#delete请求" class="headerlink" title="delete请求"></a>delete请求</h4><p>delete：删除<br>用来删除指定的资源，他会删除url给出的目标资源的所有内容</p><h4 id="option请求"><a href="#option请求" class="headerlink" title="option请求"></a>option请求</h4><p>用来描述目标资源的通信选项，返回服务器针对的特定资源所支持的http请求方法，也可以利用项web服务器发送*的请求，来测试服务器的功能性</p><h4 id="head请求"><a href="#head请求" class="headerlink" title="head请求"></a>head请求</h4><p>head方法和get方法相同，没有响应体，仅传输状态行和标题部分。</p><h4 id="connect请求"><a href="#connect请求" class="headerlink" title="connect请求"></a>connect请求</h4><p>connect请求用来建立给定url标识的服务器的隧道，她通过简单的TCP&#x2F;IP隧道更改请求连接，通常使用解码的http代理来进行ssk编码的通信</p><h4 id="trace请求"><a href="#trace请求" class="headerlink" title="trace请求"></a>trace请求</h4><p>用于沿着目标资源的路径执行消息环回测试；他回应收到的请求，一边客户可以看到中间服务器进行了哪些进度和增量</p><p>了解过vue3吗</p><h3 id="vue3里面的proxy（vue3中的数据劫持）"><a href="#vue3里面的proxy（vue3中的数据劫持）" class="headerlink" title="vue3里面的proxy（vue3中的数据劫持）"></a>vue3里面的proxy（vue3中的数据劫持）</h3><p>var proxy&#x3D;new Proxy(target,handler)<br>是代理器，用于改变某些操作的默认行为，在目标对象的外层架设置了一层拦截，外界想要访问这个属性必须要先经过proxy</p><h3 id="说一下vue中的数据劫持"><a href="#说一下vue中的数据劫持" class="headerlink" title="说一下vue中的数据劫持"></a>说一下vue中的数据劫持</h3><p>vue2中的数据劫持就是利用：Object.defineProperty()的getter和setter来监听属性的变化，当变化的时候做出的一些事情<br>说一下scss </p><h3 id="箭头函数和普通函数的区别-1"><a href="#箭头函数和普通函数的区别-1" class="headerlink" title="箭头函数和普通函数的区别"></a>箭头函数和普通函数的区别</h3><p>1、普通函数可以是声明式的，也可以是赋值式的，箭头函数只能是赋值式的<br>2、箭头函数没有自己的this,他的this是他上下文中的this，普通函数的this是指向它的调用者<br>3、普通函数可以new（通过new来作为构造函数）,箭头函数不能new，没有prototype属性<br>4、普通函数可以获取到argument对象，箭头函数没有</p><p>挂载的方法：hexo clean; hexo generate; hexo deploy </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>尚品汇</title>
      <link href="/2023/02/27/project/"/>
      <url>/2023/02/27/project/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue前台项目"><a href="#Vue前台项目" class="headerlink" title="Vue前台项目"></a>Vue前台项目</h1><p>技术架构：vue+webpack+vuex+vue-rotuer+axios+less</p><h1 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h1><p>1、跨域<br>2、过渡动画<br>3、自定义事件</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面试宝典</title>
      <link href="/2023/02/27/interview/"/>
      <url>/2023/02/27/interview/</url>
      
        <content type="html"><![CDATA[<h3 id="6种组件间通信方式"><a href="#6种组件间通信方式" class="headerlink" title="6种组件间通信方式"></a>6种组件间通信方式</h3><h4 id="props"><a href="#props" class="headerlink" title="props"></a>props</h4><p>使用场景：父子组件通信<br>注意事项：如果父组件给子组件传递数据（函数）：本质就是子组件给父组件传递数据<br>如果父组件给子组件传递的数据（非函数）：本质就是父组件给子组件提供数据</p><p>props书写方式：3种<br>数组[]<br>对象{type:Array}<br>对象 {type:Array,default:[]}</p><h5 id="传递数据："><a href="#传递数据：" class="headerlink" title="传递数据："></a>传递数据：</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Student</span> <span class="attr">uname</span>=<span class="string">&quot;羊仔&quot;</span> <span class="attr">sex</span>=<span class="string">&quot;男&quot;</span> <span class="attr">:age</span>=<span class="string">&quot;18&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Student</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在属性的前面加上冒号 --&gt;</span></span><br></pre></td></tr></table></figure><h5 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h5><pre><code>    第一种方式（只接收）：      props: [&quot;uname&quot;, &quot;sex&quot;, &quot;age&quot;],     第二种方式（限制类型）：          props: &#123;           uname: String,           sex: String,           age: Number,           &#125;,      第三种方式（限制类型、限制必要性、指定默认值）            props: &#123;              uname: &#123;                type: String, //uname的类型是字符串                required: true, //uname是必要的              &#125;,              sex: &#123;                type: String, //sex的类型是字符串                required: true, //sex是必要的              &#125;,              age: &#123;                type: Number, //age的类型是数字型                required: true, //age是必要的                default: 20, //默认值              &#125;,            &#125;,   </code></pre><p>备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。 </p><p>提示：路由的props<br>书写方式：布尔值、对象、函数</p><h4 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h4><p>使用场景：子组件给父组件传递数据<br>$on  $emit<br>1、绑定自定义事件<br>     （1）、第一种方式 ： 在父组件中<br>   <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Student</span> <span class="attr">v-on:jing</span>=<span class="string">&quot;getStudentName&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">Student</span>&gt;</span>  或  <span class="tag">&lt;<span class="name">Student</span> @<span class="attr">jing</span>=<span class="string">&quot;getStudentName&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">Student</span>&gt;</span></span><br></pre></td></tr></table></figure><br>  （2）、第二种方式： 在父组件中<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> &lt;<span class="title class_">Student</span> ref=<span class="string">&quot;student&quot;</span> &gt;&lt;/<span class="title class_">Student</span>&gt;</span><br><span class="line"> ....</span><br><span class="line"> <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">student</span>.$on(<span class="string">&quot;jing&quot;</span>, <span class="variable language_">this</span>.<span class="property">getStudentName</span>); <span class="comment">//绑定自定义事件</span></span><br><span class="line"> &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><br>  （3）、若想让自定义事件只触发一次，可以使用once修饰符 或  $once()方法</p><p>2、、触发自定义事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="variable language_">this</span>.$emit(<span class="string">&quot;jing&quot;</span>, <span class="variable language_">this</span>.<span class="property">uname</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);<span class="comment">//谁绑定了就找谁触发</span></span><br><span class="line">    </span><br><span class="line"><span class="string">``</span><span class="string">`    </span></span><br><span class="line"><span class="string">3、解绑自定义事件：</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"></span><br><span class="line">     <span class="variable language_">this</span>.$off(<span class="string">&quot;jing&quot;</span>); <span class="comment">//解绑一个自定义事件</span></span><br><span class="line">     <span class="variable language_">this</span>.$off([<span class="string">&quot;jing&quot;</span>, <span class="string">&quot;demo&quot;</span>]); <span class="comment">//解绑多个自定义事件</span></span><br><span class="line">     <span class="variable language_">this</span>.$off(); <span class="comment">//解绑所有的自定义事件</span></span><br></pre></td></tr></table></figure><p>  4、组件上也可以绑定原生DOM事件，不过需要native修饰符 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Student</span> <span class="attr">ref</span>=<span class="string">&quot;student&quot;</span> @<span class="attr">click.native</span>=<span class="string">&quot;show&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Student</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 给组件绑定原生DOM事件 后面必须加native --&gt;</span></span><br></pre></td></tr></table></figure><p>this.$destroy(); &#x2F;&#x2F;销毁了当前t组件的实例，销毁后所有组件实例的自定义事件全都不奏效了 （现在所有的事件都不奏效，包括js原生事件）</p><h4 id="全局事件总线"><a href="#全局事件总线" class="headerlink" title="全局事件总线"></a>全局事件总线</h4><p>任意组件间通信<br>$bus<br>在main.js中添加 Vue.prototype.$bus&#x3D;this<br> this.$bus.$emit提供数据<br>  this.$bus.$on接收数据</p><h4 id="pubsub-js"><a href="#pubsub-js" class="headerlink" title="pubsub-js"></a>pubsub-js</h4><p>任意组件间通信<br>在react框架中使用的比较高（发布与订阅）<br>订阅消息（需要数据的订阅消息，重要的是消息的内容）  （提供数据的发布消息，重要的是消息名）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里有两个参数，magName是消息名，data是收到的数据</span></span><br><span class="line"><span class="comment">//提供数据</span></span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">pubId</span> = pubsub.<span class="title function_">subscribe</span>(<span class="string">&quot;hello&quot;</span>, <span class="function">(<span class="params">magName, data</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;有人发布了hello消息，hello消息的回调执行了&quot;</span>, data);</span><br><span class="line">   &#125;);</span><br><span class="line">pubsub.<span class="title function_">publish</span>(<span class="string">&quot;hello&quot;</span>, <span class="number">9999</span>);<span class="comment">//接收数据</span></span><br></pre></td></tr></table></figure><h4 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h4><p>任意组件间通信</p><h5 id="安装vuex"><a href="#安装vuex" class="headerlink" title="安装vuex"></a>安装vuex</h5><p>npm i vuex@3 配合vue2使用<br>npm i vuex@4 配合vue3使用  </p><h5 id="搭建vuex环境"><a href="#搭建vuex环境" class="headerlink" title="搭建vuex环境"></a>搭建vuex环境</h5><p>1、创建文件：src&#x2F;store&#x2F;index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该文件用于创建Vuex中最为核心的store</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//引入Vue</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">//引入Vuex</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">// 使用vuex插件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>)<span class="comment">//此时vc身上就有了store这个配置项,创建Vue实例的时候就可以用store来管理actions,mutations,state</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//准备actions 用于响应组件中的动作</span></span><br><span class="line"><span class="keyword">const</span> actions = &#123;&#125;</span><br><span class="line"><span class="comment">//准备mutations  用于加工（操作）数据</span></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;&#125;</span><br><span class="line"><span class="comment">//准备state 用于存储数据</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;&#125;</span><br><span class="line"><span class="comment">//类似于计算属性  当state中的数据需要加工后在使用时，可以使用getters加工</span></span><br><span class="line"><span class="keyword">const</span> getters=&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露7store 用来管理以上三个</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">    actions,</span><br><span class="line">    mutations,</span><br><span class="line">    state,</span><br><span class="line">    getters</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>2、在main.js中创建vm时传入store配置项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入store</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Vue实例vm</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">    <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">    <span class="comment">//使用store</span></span><br><span class="line">    store,</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>组件中读取vuex中的数据</p><pre><code>    this.$store.state.sum</code></pre><p>组件中修改vuex中的数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&quot;action中的方法名&quot;</span>, 数据);</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&quot;mutations中的方法名&quot;</span>, 数据);</span><br><span class="line">备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写dispatch,直接写commit</span><br></pre></td></tr></table></figure><h4 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h4><p>使用场景：父子组件通信（通信的一般是结构）</p><h5 id="默认插槽"><a href="#默认插槽" class="headerlink" title="默认插槽"></a>默认插槽</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  父组件中</span><br><span class="line"> <span class="tag">&lt;<span class="name">Category</span> <span class="attr">title</span>=<span class="string">&quot;美食&quot;</span> <span class="attr">:list</span>=<span class="string">&quot;foods&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./assets/ppp.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">Category</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  子组件中</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;category&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; title &#125;&#125;分类<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义一个插槽（挖一个坑，等着组件的使用者来进行填充） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span>插槽，当使用者没有传具体的结构的时候，就显示这个插槽里面的东西<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">父组件中</span><br><span class="line"><span class="tag">&lt;<span class="name">Category</span> <span class="attr">title</span>=<span class="string">&quot;美食&quot;</span> <span class="attr">:list</span>=<span class="string">&quot;foods&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">slot</span>=<span class="string">&quot;center&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./assets/ppp.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">slot</span>=<span class="string">&quot;footer&quot;</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">class</span>=<span class="string">&quot;foot&quot;</span>&gt;</span>更多美食<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Category</span>&gt;</span></span><br><span class="line"></span><br><span class="line">子组件中</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;category&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; title &#125;&#125;分类<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义一个插槽（挖一个坑，等着组件的使用者来进行填充） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">      &gt;</span>插槽，当使用者没有传具体的结构的时候，就显示这个插槽里面的东西&lt;/slot</span><br><span class="line">    &gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;footer&quot;</span></span></span><br><span class="line"><span class="tag">      &gt;</span>插槽，当使用者没有传具体的结构的时候，就显示这个插槽里面的东西&lt;/slot</span><br><span class="line">    &gt;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h5><p>理解：数据在组件自身，但是数据生成的结构需要组件的使用者来决定（games数据在Category组件中，但使用数据所遍历出来的结构由App组件决定,就是说子组件决定不了自身的结构与样式）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">父组件中 </span><br><span class="line"> <span class="tag">&lt;<span class="name">Category</span> <span class="attr">title</span>=<span class="string">&quot;游戏&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">template</span> <span class="attr">scope</span>=<span class="string">&quot;games&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(g, index) in games.games&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span>&#123;&#123; g &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Category</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Category</span> <span class="attr">title</span>=<span class="string">&quot;游戏&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">&quot;games&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h4</span> <span class="attr">v-for</span>=<span class="string">&quot;(g, index) in games.games&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span>&#123;&#123; g &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Category</span>&gt;</span></span><br><span class="line"></span><br><span class="line">子组件中</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;category&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; title &#125;&#125;分类<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义一个插槽（挖一个坑，等着组件的使用者来进行填充） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:games</span>=<span class="string">&quot;games&quot;</span></span></span><br><span class="line"><span class="tag">      &gt;</span>插槽，当使用者没有传具体的结构的时候，就显示这个插槽里面的东西&lt;/slot</span><br><span class="line">    &gt;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">name</span>: <span class="string">&quot;Category&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">props</span>: [<span class="string">&quot;title&quot;</span>],</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">games</span>: [<span class="string">&quot;王者荣耀&quot;</span>, <span class="string">&quot;和平精英&quot;</span>, <span class="string">&quot;蛋仔派对&quot;</span>, <span class="string">&quot;原神&quot;</span>],</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">&#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="作用域和执行上下文的区别？"><a href="#作用域和执行上下文的区别？" class="headerlink" title="作用域和执行上下文的区别？"></a>作用域和执行上下文的区别？</h3><p>1、函数的执行上下文是在函数调用的时候生成的，而其作用域是在创建的时候就已经创建好了<br>2、作用域包含了若干个函数执行上下文，也有可能是零个（因为函数还没有执行）</p><h3 id="this的指向问题"><a href="#this的指向问题" class="headerlink" title="this的指向问题"></a>this的指向问题</h3><p>this的指向只有在调用时才能确定，因为this是执行上下文的一部分<br>1、全局作用域中的函数：this的指向是window<br>2、对象内部的函数：this的指向是其对象本身<br>3、构造函数：this的指向是他的实例对象<br>4、由apply、call、bind改造的函数：this的指向是他的第一个参数<br>5、箭头函数：箭头函数没有自己的this,他的this是其上下文中的this</p><h3 id="如何理解同步和异步"><a href="#如何理解同步和异步" class="headerlink" title="如何理解同步和异步"></a>如何理解同步和异步</h3><p>同步：同步就是按照代码的顺序，从上往下依次执行<br>异步：可以理解为是一种并行行为，意思就是可以不必等到上一段代码执行完毕，就可以执行其他的代码。<br>js之所以需要异步是因为js是单线程的，常用的异步场景有：定时器，ajax请求、事件绑定等<br>补充：<br>进程和线程<br>    进程：就是程序的运行环境（厂房）<br>    线程：就是实际进行运算的一个东西（工人）</p><p>同步和异步<br>    同步：通常情况下代码都是自上向下一行一行执行的<br>          前边的代码不执行，那么后面的也不执行<br>          同步的代码执行会出现阻塞的情况<br>          一行代码执行慢，会影响到整个代码的执行</p><p>解决同步的问题：<br>   java python :通过多线程解决<br>   node.js:通过异步方式解决</p><p>   异步：一段代码的执行不会影响其他的代码<br>     异步的代码不能通过return设置返回值<br>     特点：<br>        1、不会阻塞其他代码的执行<br>        2、需要通过回调函数来返回结果<br>    基于回调函数的异步带来的问题<br>        1、代码的可读性差<br>        2、可调试性差<br>    解决问题：Promise（存储异步调用的返回值）<br>       就是一个可以用来存储数据的对象<br>       存储数据的方式比较特殊，这种特殊方式使得Promise可以用来存储异步调用的数据</p><h3 id="实现异步的方式有哪些"><a href="#实现异步的方式有哪些" class="headerlink" title="实现异步的方式有哪些"></a>实现异步的方式有哪些</h3><p>1、回调函数<br>2、事件监听<br>3、发布订阅模式<br>4、Promise<br>5、async&#x2F;await<br>6、利用生成器实现</p><h3 id="怎样理解Promise对象"><a href="#怎样理解Promise对象" class="headerlink" title="怎样理解Promise对象"></a>怎样理解Promise对象</h3><h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>Promise：可以帮助我们解决异步中的回调函数的问题<br>         Promise就是一个用来存储数据的容器，他拥有一套特殊的存取数据的方式，这个方法可以使得他里面可以存储异步调用的数据（结果）</p><h4 id="创建Promise"><a href="#创建Promise" class="headerlink" title="创建Promise"></a>创建Promise</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Promise时，构造函数中需要一个函数作为参数（function()&#123;&#125; 和箭头函数都可以）</span></span><br><span class="line"><span class="comment">//Promise构造函数的回调函数，他会在创建Promise的时候就调用，调用时会有两个参数传递进去</span></span><br><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//resolve,reject时两个函数，通过这两个函数，可以向Promise里面存储数据</span></span><br><span class="line">  <span class="comment">//resolve在执行正常的时候存储数据，reject在执行错误时存储数据</span></span><br><span class="line">  <span class="comment">// reject(&#x27;bkpp&#x27;)</span></span><br><span class="line">  <span class="comment">//通过函数来向Promise中添加数据，好处就是可以用来添加异步调用的数据</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;pp&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">1000</span>)   </span><br><span class="line"><span class="string">``</span><span class="string">`   </span></span><br><span class="line"><span class="string">#### 读取数据</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">从Promise中读取数据</span></span><br><span class="line"><span class="comment">  通过Promise的实例方法then来读取Promise中存储的数据</span></span><br><span class="line"><span class="comment">  then方法里面需要两个回调函数来作为参数，回调函数用来获取Promise中存储的数据</span></span><br><span class="line"><span class="comment">      通过resolve存储的数据，会调用第一个函数返回,</span></span><br><span class="line"><span class="comment">            我们可以在第一个函数里面编写处理函数的代码</span></span><br><span class="line"><span class="comment">      通过reject存储的数据或者出现异常时，会调用第二个函数返回</span></span><br><span class="line"><span class="comment">          我们可以在第二个函数里面编写处理异常的代码</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">promise.<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise中的数据&#x27;</span>, result);</span><br><span class="line">&#125;, <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;promise中的数据&#x27;</span>, reason);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="string">``</span><span class="string">`   </span></span><br><span class="line"><span class="string">Promise中维护了两个隐藏的属性</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">     PromiseResult 用来存储数据</span></span><br><span class="line"><span class="string">     PromiseState 用来记录Promise的状态（三种）</span></span><br><span class="line"><span class="string">           pending (进行中)</span></span><br><span class="line"><span class="string">           fulfilled（完成）通过resolve存储数据</span></span><br><span class="line"><span class="string">           rejected (拒接，出错了) 出错了或者通过reject存储数据</span></span><br><span class="line"><span class="string">      PromiseState只能修改一次，修改后永远不会在变   pending---&gt;fulfilled  pending---&gt;rejected</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    流程：</span></span><br><span class="line"><span class="string">       当Promise创建时，Promise的初始值为pending</span></span><br><span class="line"><span class="string">          当通过resolve存储数据时， PromiseState变为 fulfilled（完成）</span></span><br><span class="line"><span class="string">              PromiseResult变为存储的数据</span></span><br><span class="line"><span class="string">          当通过reject存储数据或者出错时， PromiseState变为  rejected (拒接，出错了) </span></span><br><span class="line"><span class="string">              PromiseResult变为存储的数据 或者异常对象</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        当我们通过then读取数据的时候，相当于为Promise设置了回调函数</span></span><br><span class="line"><span class="string">          如果PromiseState变为fulfilled（完成），则调用then的第一个回调函数来返回结果</span></span><br><span class="line"><span class="string">           如果PromiseState变为 rejected (拒接，出错了)，则调用then的第二个函数来返回结果</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">           </span></span><br><span class="line"><span class="string">#### Promise中的方法</span></span><br><span class="line"><span class="string">promise中 then() catch()  finally() 都会返回一个新的Promise</span></span><br><span class="line"><span class="string">Promise中会存储回调函数的返回值 (finally除外)</span></span><br><span class="line"><span class="string">finally的返回值，不会存储到Promise中</span></span><br><span class="line"><span class="string">##### then()</span></span><br><span class="line"><span class="string">对Promise进行链式调用的时候，后面的方法读取的时前面方法的返回值</span></span><br><span class="line"><span class="string">##### catch()</span></span><br><span class="line"><span class="string">当Promise出现异常时，而整个调用链中没有catch，那么就会向外抛出异常</span></span><br><span class="line"><span class="string">catch()我们一般写在最后面，永远都是后面的解决前面的问题，catch()不能发现自身的异常，自能发现前面的异常</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Promise 中的catch</span></span><br><span class="line"><span class="string">catch()是用来处理异常的数据，当我们的数据中没有异常的数据或者错误数据，就会跳过这个catch()直接执行下一行代码</span></span><br><span class="line"><span class="string">当数据中有异常的数据，那么then()就会被跳过，而去执行catch()方法</span></span><br><span class="line"><span class="string">#### 静态方法</span></span><br><span class="line"><span class="string">静态方法（就是直接通过类调用的方法）</span></span><br><span class="line"><span class="string">    Promise.resolve(10) 创建一个立即完成的Promise</span></span><br><span class="line"><span class="string">    Promise.reject(&#x27;错误！！！&#x27;) 创建一个立即拒绝的Promise</span></span><br><span class="line"><span class="string">    Promise.all([...]) 同时返回多个Promise的执行结果,其中有一个错，就返回错误，返回的数组里面就是得到的数据</span></span><br><span class="line"><span class="string">    Promise.allSettled([...]),同时返回多个Promise的执行结果,无论成功或失败，都会返回，返回的数组里面是对象型的</span></span><br><span class="line"><span class="string">          &#123;status: &#x27;fulfilled&#x27;, value: 3&#125;</span></span><br><span class="line"><span class="string">          &#123;status: &#x27;rejected&#x27;, reason: 10&#125;</span></span><br><span class="line"><span class="string">    Promise.race([...]) 返回执行最快的Promise,不考虑对错，都返回</span></span><br><span class="line"><span class="string">    Promise.any([...])  返回完成最快的Promise,只有当所有的都为reject的情况下才报错</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#### Promise对象有以下两个特点：</span></span><br><span class="line"><span class="string">1、对象的状态不受外界的影响。Promise对象一共有三种状态，pending、fulfilled、rejected。状态值只会被异步的结果决定，其他操作无法改变。</span></span><br><span class="line"><span class="string">2、状态一旦改变，就不会再变，且任何时候都可以得到这个结果。状态值会由pending--&gt;fulfilled或pending--&gt;rejected，这时既是resloved</span></span><br><span class="line"><span class="string">#### Promise有以下三个缺点：</span></span><br><span class="line"><span class="string">1、Promise一旦执行就无法取消</span></span><br><span class="line"><span class="string">2、不可设置回调函数，其内部的错误无法捕获</span></span><br><span class="line"><span class="string">3、当Promise处于pending的时候，无法得知具体发展道路那一步</span></span><br><span class="line"><span class="string">Promise中常用的方法（记得敲代码）</span></span><br><span class="line"><span class="string">1、.then()  .catch() </span></span><br><span class="line"><span class="string">#### Promise的执行原理</span></span><br><span class="line"><span class="string"> Promise在执行的时候，then就相当于给Promise一个回调函数</span></span><br><span class="line"><span class="string">    当Promise的状态从pending---&gt;fulfilled时</span></span><br><span class="line"><span class="string">    then的回调函数就会被放入任务队列中</span></span><br><span class="line"><span class="string">### 事件委派</span></span><br><span class="line"><span class="string">事件委派也叫做事件代理，就是不在子元素上绑定事件监听器，而是把子元素的的事件都绑定到父元素的身上，利用事件冒泡的原理进行</span></span><br><span class="line"><span class="string">### 解释一下变量提升</span></span><br><span class="line"><span class="string">变量提升是js的默认行为，这意味着将所有的变量提升到当前作用域的顶部，并且可以在声明之前使用变量。初始化不会被提升，提升仅作用于白能量的声明。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### cooKies机制和session机制的区别</span></span><br><span class="line"><span class="string">1、cookies数据保存在客户端，session数据保存在服务端</span></span><br><span class="line"><span class="string">2、cookies可以减轻服务器的压力，但是不安全，容易进行cookies欺骗</span></span><br><span class="line"><span class="string">3、session安全一点，但是占用服务器资源</span></span><br><span class="line"><span class="string">### get和post的区别</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">1、url可见性</span></span><br><span class="line"><span class="string">get:url参数可见，post：url参数不可见</span></span><br><span class="line"><span class="string">2、数据传输上</span></span><br><span class="line"><span class="string">get:通过拼接url进行传递参数</span></span><br><span class="line"><span class="string">post:通过body体传递参数</span></span><br><span class="line"><span class="string">3、缓存性</span></span><br><span class="line"><span class="string">get请求是可以缓存的，post请求不可以缓存</span></span><br><span class="line"><span class="string">4、后退页面的反应</span></span><br><span class="line"><span class="string">get请求页面后退时，不产生影响</span></span><br><span class="line"><span class="string">post请求页面后退时，会重新提交请求</span></span><br><span class="line"><span class="string">5、传输的数据大小</span></span><br><span class="line"><span class="string">get一般传输的数据大小不超过2k-4k</span></span><br><span class="line"><span class="string">post请求传输的数据大小根据php.ini配置文件设定，也可以无限大</span></span><br><span class="line"><span class="string">6、安全性</span></span><br><span class="line"><span class="string">原则上post肯定要比get请求安全，毕竟传输参数时url不可见，但是有人闲的没事会抓包，所以也没啥区别</span></span><br><span class="line"><span class="string">7、数据包</span></span><br><span class="line"><span class="string">简单来说，get产生一个TCP数据包，post生成两个TCP数据包，对于get方式的请求，浏览器会把http header和data一并发送出去，然后服务器响应200（返回数据）；对于post来说，浏览器会先发送header,服务器响应100 continue,浏览器在发送data,服务器响应200（返回数据）</span></span><br><span class="line"><span class="string">### textContent,innerText,innerHTML,value的区别</span></span><br><span class="line"><span class="string">1、textContent用来获取和设置文本内容，与innerText不同的是textContent可以获取到的内容包括了元素中的style标签和script标签的内容</span></span><br><span class="line"><span class="string">2、innerText只能获取和设置文本内容。不能设置html标签</span></span><br><span class="line"><span class="string">3、innerHTML可以获取和设置html标签</span></span><br><span class="line"><span class="string">4、value，用来获取表单数据</span></span><br><span class="line"><span class="string">### 什么叫DOM事件流</span></span><br><span class="line"><span class="string">事件发生时会在元素节点之间按照特定的顺序传播，整个过程分为捕获阶段、目标阶段和冒泡阶段，这个传播过程就是DOM事件流</span></span><br><span class="line"><span class="string">事件冒泡：就是从小到大，事件源到document</span></span><br><span class="line"><span class="string">事件捕获：就是从大到小，document到事件源</span></span><br><span class="line"><span class="string">### 如何让事件先冒泡后捕获</span></span><br><span class="line"><span class="string">在原本的的事件流中，是先捕获在冒泡</span></span><br><span class="line"><span class="string">可以给目标元素，绑定两个事件监听器，一个用于冒泡，一个用于捕获，然后将两个事件的执行顺序是按照代码的顺序执行的，所以先写冒泡，在写捕获，让弄胡就会按照这个歌顺序执行</span></span><br><span class="line"><span class="string">如果是对于非目标元素，给捕获的事件加上一个定时器，这时捕获事件就成为了异步任务，进入了宏任务队列中，这样做的目的就是让冒泡事件执行完在执行捕获事件。</span></span><br><span class="line"><span class="string">### js的执行机制</span></span><br><span class="line"><span class="string">JS是单线程的，他的运行基于事件循环(event loop) </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    调用栈</span></span><br><span class="line"><span class="string">       栈</span></span><br><span class="line"><span class="string">          栈是一种数据结构，后进先出</span></span><br><span class="line"><span class="string">       调用栈中，放的是要执行的代码 </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    任务队列</span></span><br><span class="line"><span class="string">      队列</span></span><br><span class="line"><span class="string">         队列是一种数据结构，先进先出</span></span><br><span class="line"><span class="string">      任务队列里面的是将要执行的代码</span></span><br><span class="line"><span class="string">      当调用栈中的代码执行完成后，任务队列中的代码才会按照顺序依次进入到栈中执行</span></span><br><span class="line"><span class="string">      在JS中任务队列有两种</span></span><br><span class="line"><span class="string">        一种是宏任务队列：大部分代码都去宏任务队列中排队</span></span><br><span class="line"><span class="string">        另一种是微任务队列：promise的回调函数（then.catch finally）他们就回去微任务队列中排队</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    整个流程：</span></span><br><span class="line"><span class="string">       1、执行调用栈里面的代码</span></span><br><span class="line"><span class="string">       2、执行微任务队列里面所有的任务，</span></span><br><span class="line"><span class="string">       3、当微任务队列中的所有执行完毕之后，在去执行宏任务队列中的</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">主线程----&gt;微任务队列----&gt;宏任务队列  </span></span><br><span class="line"><span class="string">微任务：   </span></span><br><span class="line"><span class="string"> process.nextTick(node 独有)</span></span><br><span class="line"><span class="string"> promise的方法   </span></span><br><span class="line"><span class="string"> MutationObserver</span></span><br><span class="line"><span class="string"> 宏任务：</span></span><br><span class="line"><span class="string"> script</span></span><br><span class="line"><span class="string">setTimeout</span></span><br><span class="line"><span class="string">setInterval</span></span><br><span class="line"><span class="string">setImmediate</span></span><br><span class="line"><span class="string">I/O</span></span><br><span class="line"><span class="string">UI rendering</span></span><br><span class="line"><span class="string">### 说一下BFC</span></span><br><span class="line"><span class="string">BFC（block formatting content）块级格式化上下文  </span></span><br><span class="line"><span class="string">是web页面中盒模型布局的css渲染模式，值得是一个独立的空间，就像是一个容器，容器里面的内容不会影响外面的元素</span></span><br><span class="line"><span class="string">#### 形成BFC的条件</span></span><br><span class="line"><span class="string">overflow: hidden</span></span><br><span class="line"><span class="string">display: inline-block</span></span><br><span class="line"><span class="string">position: absolute</span></span><br><span class="line"><span class="string">position: fixed</span></span><br><span class="line"><span class="string">display: table-cell</span></span><br><span class="line"><span class="string">display: flex</span></span><br><span class="line"><span class="string">#### BFC的规则</span></span><br><span class="line"><span class="string">BFC就是一个块级元素，块级元素会在垂直方向一个接一个的排列</span></span><br><span class="line"><span class="string">BFC就是页面中的一个隔离的独立容器，容器里的标签不会影响到外部标签</span></span><br><span class="line"><span class="string">垂直方向的距离由margin决定， 属于同一个BFC的两个相邻的标签外边距会发生重叠</span></span><br><span class="line"><span class="string">计算BFC的高度时，浮动元素也参与计算</span></span><br><span class="line"><span class="string">#### BFC解决了什么问题</span></span><br><span class="line"><span class="string">1.使用Float脱离文档流，高度塌陷</span></span><br><span class="line"><span class="string">2.Margin边距重叠</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 说一下语义化标签</span></span><br><span class="line"><span class="string">在我们开发的过程中，尽量多的使用一些有语意的标签，如：header footer nav ul li等，避免大量使用无语意的标签，如div</span></span><br><span class="line"><span class="string">语义化标签的优点</span></span><br><span class="line"><span class="string">1、对开发者，语义化标签有着更好的页面结构，利于个人代码的编写</span></span><br><span class="line"><span class="string">2、对于用户来说，当网络卡顿的时候，有良好的页面结构，有利于增加个人体验感</span></span><br><span class="line"><span class="string">3、对于爬虫来说，有利于搜索引擎的seo优化，有利于网站获得更靠前的排名</span></span><br><span class="line"><span class="string">4、对于团队来说，有利于代码的开发和后期维护</span></span><br><span class="line"><span class="string">### 说一下CSS盒模型</span></span><br><span class="line"><span class="string">标准盒模型：box-sizing:context-box  width就是文本的宽度，padding和border会撑大盒子</span></span><br><span class="line"><span class="string">怪异盒模型:box-sizing:border-box  width就是text+padding+border </span></span><br><span class="line"><span class="string">### 定位postition</span></span><br><span class="line"><span class="string">fixed 固定定位  脱标 相对于视窗进行偏移</span></span><br><span class="line"><span class="string">absoult 绝对定位 脱标 相对于有定位的父元素</span></span><br><span class="line"><span class="string">relative 相对定位 不脱表 相对于自身元素进行偏移 </span></span><br><span class="line"><span class="string">stick 粘性定位 必须设置top right left bottom 的任何一个才可以</span></span><br><span class="line"><span class="string">### C3的新特性</span></span><br><span class="line"><span class="string">border-radius 圆角边框</span></span><br><span class="line"><span class="string">border-image 边框图片</span></span><br><span class="line"><span class="string">border-width</span></span><br><span class="line"><span class="string">box-shadow 盒子阴影</span></span><br><span class="line"><span class="string">text-shadow 文字阴影</span></span><br><span class="line"><span class="string">linear-gradient 线性渐变</span></span><br><span class="line"><span class="string">radial-gradient 径向渐变</span></span><br><span class="line"><span class="string">2D/3D转换 transsform:rotate(旋转) scale(缩放) teanslate(移动)</span></span><br><span class="line"><span class="string">媒体查询 @media:根据屏幕宽度，，设置，用来解决移动端适配的问题，根据屏幕大小是相应的css生效</span></span><br><span class="line"><span class="string">flex布局</span></span><br><span class="line"><span class="string">### 实现元素隐藏</span></span><br><span class="line"><span class="string">visibility:hidden 占位 源码可见</span></span><br><span class="line"><span class="string">display:none 不占为 源码可见</span></span><br><span class="line"><span class="string">opacity:0 占位 源码可见 透明度为0</span></span><br><span class="line"><span class="string">position:top:-999px ,left:-999px  利用定位将元素移除视窗</span></span><br><span class="line"><span class="string">### 如何实现元素水平居中</span></span><br><span class="line"><span class="string">行内元素：text-algin:center</span></span><br><span class="line"><span class="string">块元素:margin:0 auto</span></span><br><span class="line"><span class="string">position:left:50%;transform:translate(-50%)</span></span><br><span class="line"><span class="string">### 如何实现元素垂直居中</span></span><br><span class="line"><span class="string">1、linn-height:height</span></span><br><span class="line"><span class="string">2、verticle-algin:center</span></span><br><span class="line"><span class="string">3、position:top:50%;transform:translate(0,-50%)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 清除浮动</span></span><br><span class="line"><span class="string">1、给父元素添加高度</span></span><br><span class="line"><span class="string">2、overflow:hidden</span></span><br><span class="line"><span class="string">3、额外标签法：加一个空div，添加样式clear:both</span></span><br><span class="line"><span class="string">4、伪元素（给浮动元素的父亲加）</span></span><br><span class="line"><span class="string">.clearfix::after&#123;</span></span><br><span class="line"><span class="string">  context:&#x27;&#x27;,</span></span><br><span class="line"><span class="string">  display:none,</span></span><br><span class="line"><span class="string">  clear:both</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">### css中的选择器，选择器的优先级</span></span><br><span class="line"><span class="string">### 闭包</span></span><br><span class="line"><span class="string">### 原型与原型链</span></span><br><span class="line"><span class="string">### 数据类型</span></span><br><span class="line"><span class="string">### 判断数据类型的方法有那些</span></span><br><span class="line"><span class="string">### 浅拷贝和深拷贝</span></span><br><span class="line"><span class="string">### let和const的区别</span></span><br><span class="line"><span class="string">### 神魔是执行上下文和执行上下文栈</span></span><br><span class="line"><span class="string">### 什么是作用域和作用域链</span></span><br><span class="line"><span class="string">### 什么是跨域</span></span><br><span class="line"><span class="string">### HttP协议</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  网络基础</span></span><br><span class="line"><span class="string">  网络的服务是基于 请求和相应的</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">     https:// lilichao.com /hello/index.html   </span></span><br><span class="line"><span class="string">      https:// 协议名</span></span><br><span class="line"><span class="string">      lilichao.com 域名 整个网络中存在着无数个服务器， 每一个服务器都有他自己的唯一标识 ，</span></span><br><span class="line"><span class="string">             这个标识被称为ip地址 192.168.1.17.但是ip地址不方便记忆，域名就相当于ip地址</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      /hello/index.html 网站资源的路径  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#### 当在浏览器中输入地址后发生了什么</span></span><br><span class="line"><span class="string">     https:// lilichao.com /hello/index.html         </span></span><br><span class="line"><span class="string">      a、DNS解析，获取网站的ip地址</span></span><br><span class="line"><span class="string">         通过网址去查找服务器的ip地址  （DNS相当于电话本，ip地址相当于电话号）</span></span><br><span class="line"><span class="string">      b、浏览器需要和服务器建立连接（tcp/ip） (通过三次握手建立连接)</span></span><br><span class="line"><span class="string">      c、向服务器发送请求 (HttP协议)</span></span><br><span class="line"><span class="string">      d、服务器处理请求，并返回响应 （http协议）</span></span><br><span class="line"><span class="string">      e、浏览器将相应的页面进行渲染</span></span><br><span class="line"><span class="string">      f、断开和服务器的连接 （四次挥手）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      建立是客户端建立，断开是谁发数据谁断开（一般是服务器断开的多）</span></span><br><span class="line"><span class="string">          </span></span><br><span class="line"><span class="string">          </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#### 客服端如何和服务器建立（断开）连接</span></span><br><span class="line"><span class="string">       通过三次握手（建立）和四次挥手（断开）</span></span><br><span class="line"><span class="string">##### 三次握手（建立连接）</span></span><br><span class="line"><span class="string">         是客服端和服务器建立连接的过程</span></span><br><span class="line"><span class="string">           1、客服端向服务器发送连接请求</span></span><br><span class="line"><span class="string">               SYN</span></span><br><span class="line"><span class="string">           2、服务器收到连接请求，向客户端返回消息</span></span><br><span class="line"><span class="string">              ACK（同意） SYN (申请和客户端连接)  </span></span><br><span class="line"><span class="string">           3、客户端向服务器发送同意连接的请求</span></span><br><span class="line"><span class="string">              ACK（同意）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">##### 四次挥手 （断开连接）</span></span><br><span class="line"><span class="string">          1、客户端向服务器发送请求，向服务器发送数据完毕，请求断开连接</span></span><br><span class="line"><span class="string">               FIN</span></span><br><span class="line"><span class="string">          2、服务器笑傲那个客户端返回数据，知道了</span></span><br><span class="line"><span class="string">              ACK</span></span><br><span class="line"><span class="string">          3、服务器向客户端返回数据，数据收完了，可以断开连接</span></span><br><span class="line"><span class="string">              FIN  ACK</span></span><br><span class="line"><span class="string">          4、客户端向服务器发送数据，我知道了，可以断开</span></span><br><span class="line"><span class="string">               ACK</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">         请求和相应实质上就是一段数据，只是这段数据要遵循一个特殊的格式</span></span><br><span class="line"><span class="string">            这个特殊的格式就是由HTTP协议决定 （http协议就是规定请求和相应的协议的） </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">         </span></span><br><span class="line"><span class="string">### TCP/IP 协议族  </span></span><br><span class="line"><span class="string">    TCP/IP 协议族 中包含了一组协议</span></span><br><span class="line"><span class="string">    这组协议规定了互联网中所有的通信的细节 （http协议就是这里面的一个）</span></span><br><span class="line"><span class="string">#### 网络通信的过程 由四层组成</span></span><br><span class="line"><span class="string">           发数据 从上到下</span></span><br><span class="line"><span class="string">           1、应用层</span></span><br><span class="line"><span class="string">               软件的层面，浏览器，服务器都属于应用层</span></span><br><span class="line"><span class="string">           2、传输层（负责拆包，把大文件拆成一个一个的小包，丢包不会有大的影响）</span></span><br><span class="line"><span class="string">               负责对数据进行拆分，把大数据拆分成一个一个的小包</span></span><br><span class="line"><span class="string">           3、网络层 （）</span></span><br><span class="line"><span class="string">                 负责给数据盖戳，添加信息</span></span><br><span class="line"><span class="string">           4、数据链路层</span></span><br><span class="line"><span class="string">                 负责传输信息</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">          HttP协议就是应用层的协议，用来规定客户端和服务器之间通信的报文格式</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#### 服务器的主要功能就是</span></span><br><span class="line"><span class="string">           1、可以接收到浏览器发送的请求报文</span></span><br><span class="line"><span class="string">           2、可以向浏览器返回响应报文</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#### 报文是什么？（message）</span></span><br><span class="line"><span class="string">    浏览器和服务器之间的通信是基于请求和相应的</span></span><br><span class="line"><span class="string">     浏览器向服务器发送请求（request）</span></span><br><span class="line"><span class="string">      服务器向浏览器返回相应（response）</span></span><br><span class="line"><span class="string">        浏览器向服务器发送请求，相当于浏览器给服务器写信</span></span><br><span class="line"><span class="string">        服务器向浏览器返回相应，相当于服务器给浏览器回信       </span></span><br><span class="line"><span class="string">        这个信在HTTP协议中就称为报文，而HTTP协议就是对这个报文进行规定的</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">##### 请求报文（request）</span></span><br><span class="line"><span class="string">              客户端发给浏览器的的报文成为请求报文</span></span><br><span class="line"><span class="string">              请求报文的格式如下：</span></span><br><span class="line"><span class="string">                 请求首行</span></span><br><span class="line"><span class="string">                 请求头</span></span><br><span class="line"><span class="string">                 空行（分割的作用）</span></span><br><span class="line"><span class="string">                 请求体</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            请求首行：就是请求报文的第一行</span></span><br><span class="line"><span class="string">               GET    /06-http%E5%8D%8F%E8%AE%AE/01-http%E5%8D%8F%E8%AE%AE.html?username=%E9%9D%99%E9%A6%99  HTTP/1.1</span></span><br><span class="line"><span class="string">                第一部分 GET 表示请求的方式  get表示发送的是get请求</span></span><br><span class="line"><span class="string">                  现在常用的方式就是get和post请求</span></span><br><span class="line"><span class="string">                  get请求用来向服务器请求资源</span></span><br><span class="line"><span class="string">                  post请求主要用来向服务器发送数据</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">               第二部分</span></span><br><span class="line"><span class="string">               /06-http%E5%8D%8F%E8%AE%AE/01-http%E5%8D%8F%E8%AE%AE.html?username=%E9%9D%99%E9%A6%99   </span></span><br><span class="line"><span class="string">                 表示请求资源的路径</span></span><br><span class="line"><span class="string">                   ？后面的内容叫查询字符串</span></span><br><span class="line"><span class="string">                   查询字符串是一个名值对结构，一个名字对应一个值</span></span><br><span class="line"><span class="string">                    使用 = 连接，多个名值对之间用 &amp;分割   username=静香&amp;password=1234</span></span><br><span class="line"><span class="string">                   get请求通过查询字符串将数据发送给服务器</span></span><br><span class="line"><span class="string">                      由于查询字符串会在浏览器地址栏中显示</span></span><br><span class="line"><span class="string">                      所以他安全性较差</span></span><br><span class="line"><span class="string">                      get请求没有请求体，同时由于url地址长度有限，所以get请求无法发送较大的数据</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                  post请求通过请求体来发送数据</span></span><br><span class="line"><span class="string">                    在浏览器中通过载荷来查看</span></span><br><span class="line"><span class="string">                    post请求通过请求体发送数据，无法在地址栏直接查看，所以安全性较好</span></span><br><span class="line"><span class="string">                    请求体的大小没有限制，可以奉送任意大小的数据</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">                  如果需要向服务器发送请求，尽量用post</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">               第三部分 HTTP/1.1</span></span><br><span class="line"><span class="string">                 表示http协议的版本</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            请求头：名值对结构，给服务器看的，用来告诉服务器我们浏览器的信息</span></span><br><span class="line"><span class="string">                每一个请求头都有他的作用</span></span><br><span class="line"><span class="string">                 Accept；浏览器可以接受的文件类型</span></span><br><span class="line"><span class="string">                 Accept-Encoding ：浏览器允许的压缩的编码</span></span><br><span class="line"><span class="string">                 Accept-Language：客户端可以接受的语言</span></span><br><span class="line"><span class="string">                  User-Agent：用户代理 （用来描述浏览器信息的字符串）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            空行：用来分割请求头和请求体</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">            请求体</span></span><br><span class="line"><span class="string">              post通过请求体来发送数据      </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">             请求报文：</span></span><br><span class="line"><span class="string">             GET /06-http%E5%8D%8F%E8%AE%AE/01-http%E5%8D%8F%E8%AE%AE.html?username=%E9%9D%99%E9%A6%99 HTTP/1.1 </span></span><br><span class="line"><span class="string">             Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span></span><br><span class="line"><span class="string">             Accept-Encoding: gzip, deflate, br</span></span><br><span class="line"><span class="string">             Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6</span></span><br><span class="line"><span class="string">             Connection: keep-alive</span></span><br><span class="line"><span class="string">             Host: 127.0.0.1:5500</span></span><br><span class="line"><span class="string">             Referer: http://127.0.0.1:5500/06-http%E5%8D%8F%E8%AE%AE/01-http%E5%8D%8F%E8%AE%AE.html</span></span><br><span class="line"><span class="string">             Sec-Fetch-Dest: document</span></span><br><span class="line"><span class="string">             Sec-Fetch-Mode: navigate</span></span><br><span class="line"><span class="string">             Sec-Fetch-Site: same-origin</span></span><br><span class="line"><span class="string">             Sec-Fetch-User: ?1</span></span><br><span class="line"><span class="string">             Upgrade-Insecure-Requests: 1</span></span><br><span class="line"><span class="string">             User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/107.0.0.0 Safari/537.36 Edg/107.0.1418.62</span></span><br><span class="line"><span class="string">             sec-ch-ua: &quot;Microsoft Edge&quot;;v=&quot;107&quot;, &quot;Chromium&quot;;v=&quot;107&quot;, &quot;Not=A?Brand&quot;;v=&quot;24&quot;</span></span><br><span class="line"><span class="string">             sec-ch-ua-mobile: ?0</span></span><br><span class="line"><span class="string">             sec-ch-ua-platform: &quot;Windows&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">##### 响应报文：</span></span><br><span class="line"><span class="string">         响应首行</span></span><br><span class="line"><span class="string">         响应头</span></span><br><span class="line"><span class="string">         空行（分割的作用）</span></span><br><span class="line"><span class="string">         响应体</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">         响应首行</span></span><br><span class="line"><span class="string">              HTTP/1.1 405 Method Not Allowed</span></span><br><span class="line"><span class="string">              HTTP/1.1 HttP协议版本</span></span><br><span class="line"><span class="string">               405 表示响应状态码</span></span><br><span class="line"><span class="string">               Method Not Allowed 表示对响应状态码的描述</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">               响应状态码的规则</span></span><br><span class="line"><span class="string">                 1xxx 请求处理中</span></span><br><span class="line"><span class="string">                 2xxx 表示成功</span></span><br><span class="line"><span class="string">                 3xxx 表示请求的重定向</span></span><br><span class="line"><span class="string">                 4xxx 表示客户端错误</span></span><br><span class="line"><span class="string">                 5xxx 表示服务器错误</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">         响应头</span></span><br><span class="line"><span class="string">           也是一个一个的名值对结构，用来告诉浏览器响应的信息</span></span><br><span class="line"><span class="string">             Content-Type：用来描述响应体的类型</span></span><br><span class="line"><span class="string">               Content-Length：用来描述响应体的大小</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">          Access-Control-Allow-Origin: http://127.0.0.1:5500</span></span><br><span class="line"><span class="string">          Vary: Origin</span></span><br><span class="line"><span class="string">          Access-Control-Allow-Credentials: true</span></span><br><span class="line"><span class="string">          Allow: GET, HEAD, OPTIONS</span></span><br><span class="line"><span class="string">          Content-Length: 0</span></span><br><span class="line"><span class="string">          Date: Tue, 06 Dec 2022 04:21:24 GMT</span></span><br><span class="line"><span class="string">          Connection: keep-alive</span></span><br><span class="line"><span class="string">          Keep-Alive: timeout=5</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">         空行（分割的作用）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">           用来分割响应头和响应体</span></span><br><span class="line"><span class="string">         响应体</span></span><br><span class="line"><span class="string">            响应体就是服务器返回给客户端的内容</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">          HTTP/1.1 405 Method Not Allowed</span></span><br><span class="line"><span class="string">          Access-Control-Allow-Origin: http://127.0.0.1:5500</span></span><br><span class="line"><span class="string">          Vary: Origin</span></span><br><span class="line"><span class="string">          Access-Control-Allow-Credentials: true</span></span><br><span class="line"><span class="string">          Allow: GET, HEAD, OPTIONS</span></span><br><span class="line"><span class="string">          Content-Length: 0</span></span><br><span class="line"><span class="string">          Date: Tue, 06 Dec 2022 04:21:24 GMT</span></span><br><span class="line"><span class="string">          Connection: keep-alive</span></span><br><span class="line"><span class="string">          Keep-Alive: timeout=5</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### IP 内网IP 公网IP 子网掩码</span></span><br><span class="line"><span class="string">### TCP和UDP的区别</span></span><br><span class="line"><span class="string">### TCP怎么做到可靠的</span></span><br><span class="line"><span class="string">### HTTP状态码</span></span><br><span class="line"><span class="string">200 访问资源成功</span></span><br><span class="line"><span class="string">201 请求已经成功，并创建了一个新的资源 这通常是在 POST 请求，或是某些 PUT 请求之后返回的响应。</span></span><br><span class="line"><span class="string">404 访问的资源不存在 </span></span><br><span class="line"><span class="string">403 没有访问权限</span></span><br><span class="line"><span class="string">500 服务器遇到了不知道如何处理的情况。</span></span><br><span class="line"><span class="string">505</span></span><br><span class="line"><span class="string">### HTTP是无状态的还是有状态的？什么叫做无状态</span></span><br><span class="line"><span class="string">http是无状态的，无状态的意思是指：数据的请求、响应和返回都是独立的，他不会记住用户上一步干了什么</span></span><br><span class="line"><span class="string">### cookie和session</span></span><br><span class="line"><span class="string">cookie数据保存在客户端，session数据保存在服务端</span></span><br><span class="line"><span class="string">cookie不占用服务器的资源，但是不安全，容易造成cookie欺骗</span></span><br><span class="line"><span class="string">session安全，但是占用服务器资源</span></span><br><span class="line"><span class="string">### 用过的flex属性</span></span><br><span class="line"><span class="string">justfiy-content 水平方向上的</span></span><br><span class="line"><span class="string">align-self  子元素在y轴的对齐方式</span></span><br><span class="line"><span class="string">flex-warp  换行</span></span><br><span class="line"><span class="string">flex-direction: 更换主轴的方向</span></span><br><span class="line"><span class="string">### 实现布局：左侧固定，右侧自适应</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### flex:1是什么意思</span></span><br><span class="line"><span class="string">表示当前元素自动占满剩余的空间，如果有多个元素有flex:1,则表示剩余空间均匀分配</span></span><br><span class="line"><span class="string">flex：1即为flex-grow：1，经常用作自适应布局，将父容器的display：flex，侧边栏大小固定后，将内容区flex：1，内容区则会自动放大占满剩余空间。</span></span><br><span class="line"><span class="string">### css的常用单位</span></span><br><span class="line"><span class="string">px 绝对单位</span></span><br><span class="line"><span class="string">以下都是相对单位</span></span><br><span class="line"><span class="string">em：是相对于自身的font-size,如果自身没有就是相对于父元素</span></span><br><span class="line"><span class="string">rem：相对于根元素的font-size</span></span><br><span class="line"><span class="string">vm:相对于视口的宽度的1%</span></span><br><span class="line"><span class="string">vh：相对于漱口的高度1%</span></span><br><span class="line"><span class="string">%：相对于当前元素的父元素的宽高</span></span><br><span class="line"><span class="string">### 使用过的es6新特性</span></span><br><span class="line"><span class="string">let const声明变量的关键字</span></span><br><span class="line"><span class="string">简单数据类型 Symbol 表示单一的</span></span><br><span class="line"><span class="string">模板字符串</span></span><br><span class="line"><span class="string">扩展运算符</span></span><br><span class="line"><span class="string">Map  Set</span></span><br><span class="line"><span class="string">Promise</span></span><br><span class="line"><span class="string">箭头函数</span></span><br><span class="line"><span class="string">### 箭头函数的特点，用call和apply能改变箭头函数this的指向</span></span><br><span class="line"><span class="string">当箭头函数的参数只有一个时，就可以省略括号，当return的返回值只有一个语句时，就可以省略return</span></span><br><span class="line"><span class="string">箭头函数没有自己的this，他的this是他所在上下文中的this，没有argument，不能使用new，因为没有prototype</span></span><br><span class="line"><span class="string">普通函数可以使用赋值式的，也可以使用声明式的，箭头函数只能使用赋值式的</span></span><br><span class="line"><span class="string">call和apply不能直接的修改箭头函数的this，他只能通过修改箭头函数上下文中的this以此来改变箭头函数的this</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 如何获取箭头函数的所有参数</span></span><br><span class="line"><span class="string">普通函数可以通过argument来获取参数列表，argument是一个伪数组，可以使用Array.from(argument)将他转换伪真正的数组</span></span><br><span class="line"><span class="string">箭头函数无法使用argument获取参数，所以我们可以使用ES6的解构来获取（扩展运算符）</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">func</span>=(<span class="params">...arr</span>)=&gt;&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(arr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">func</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure><h3 id="js数组的方法"><a href="#js数组的方法" class="headerlink" title="js数组的方法"></a>js数组的方法</h3><p>join() 数组转换为字符串<br>push() 数组最后添加一个数<br>shift() 数组最前面添加一个数<br>pop() 删除数组最后一个数<br>unshift() 删除数组最前面一个数<br>concat()  合并数组<br>indexOf() 判断元素是否在数组中，如果数组中有，就返回第一次出现的位置（索引），如果没有就返回-1<br>includes() 判断元素是否在数组中 ，有 true 没有 false<br>filiter() 过滤数组<br>forEach() 遍历数组<br>some() 找到一个符合的就返回true<br>every() 全部都符合返回true<br>map() 遍历数组，用来重构数组<br>Array.from()  内置对象Array的方法，实例数组不能调用，可以将可迭代对象转换为新的数组<br>Array.of() ES6新增的方法，把传入的参数，当作数组元素，产生新的数组<br>sort() 排序<br>reverse() 反转数组<br>slice() 截取数组<br>splice() 更新数组<br>find() 返回第一个符合条件的值</p><h3 id="那些方法可以改变数组本身"><a href="#那些方法可以改变数组本身" class="headerlink" title="那些方法可以改变数组本身"></a>那些方法可以改变数组本身</h3><h3 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h3><p>数组扁平化就是把多个嵌套的数组，变成一个数组<br>1、利用递归<br>2、flat(Infinty) 方法<br>3、some()+扩展运算符<br>4、toString+split+map<br>5、reduce((prev,cur)&#x3D;&gt;{},[])</p><h3 id="路由的两种模式"><a href="#路由的两种模式" class="headerlink" title="路由的两种模式"></a>路由的两种模式</h3><p>hash  url中带有#（在域名的后面） 就是hash路由   history模式<br>特点：hash虽然出现在了url中，但是不会被包含在http请求中，对后端完全没有影响，因此改变hash不会重新加载页面<br>hash模式下，仅仅hash符号以前的内容会被包含在请求中，因此对于后端来说，即使没有做到完全覆盖，也不会报404的错误<br>histor模式下，前端的url必须和实际向后端发起请求的url一致，不然会报404（不怕前进，不怕后退，就怕刷新，因为刷新时实实在在的向服务器发请求）<br>history多了两个修改历史状态的API：pushState()和replceState(),通过这两个API， 可改变url的地址且不会发请求，不仅可以读取历史记录栈，还可以对浏览器历史记录栈进行修改</p><h3 id="vue路由原理"><a href="#vue路由原理" class="headerlink" title="vue路由原理"></a>vue路由原理</h3><p>本质就是监听url的变化，然后匹配路由规则，显示相应的页面，并且不刷新页面<br>有两种路由模式：hash模式 和 history模式<br>区别：<br>1、history模式美观，hash模式 域名后面加了一个#,不美观<br>2、history模式跳转当前路由会在历史记录里新增一条记录，hash模式只有在跳转路由与当前路由不一致时才会增加<br>3、history模式刷新页面会向服务器发请求，所以需要后端配合，否则页面报404，hash模式则不会，只是执行loading事件</p><h3 id="js基本数据类型"><a href="#js基本数据类型" class="headerlink" title="js基本数据类型"></a>js基本数据类型</h3><p>null undefined string symbol number boolean<br>复杂数据类型 ：函数 对象 数组</p><h3 id="js检测数据类型的方法"><a href="#js检测数据类型的方法" class="headerlink" title="js检测数据类型的方法"></a>js检测数据类型的方法</h3><p>1、typeof unll object array 返回的都是对象<br>2、instanceof  可以判断复杂数据类型,因为instanceof时用于监测构造函数的prototype是否出现在某个实例对象的原型链上<br>3、Object.prototype.toSting.call<br>4、constructor 不能判断undefined 和 null </p><h3 id="MVVM、MVC、MVP模式"><a href="#MVVM、MVC、MVP模式" class="headerlink" title="MVVM、MVC、MVP模式"></a>MVVM、MVC、MVP模式</h3><h3 id="vue的基本原理"><a href="#vue的基本原理" class="headerlink" title="vue的基本原理"></a>vue的基本原理</h3><h3 id="vue数据双向绑定的原理（响应式原理）"><a href="#vue数据双向绑定的原理（响应式原理）" class="headerlink" title="vue数据双向绑定的原理（响应式原理）"></a>vue数据双向绑定的原理（响应式原理）</h3><h3 id="getter和setter的作用"><a href="#getter和setter的作用" class="headerlink" title="getter和setter的作用"></a>getter和setter的作用</h3><h3 id="数组常用的排序方法"><a href="#数组常用的排序方法" class="headerlink" title="数组常用的排序方法"></a>数组常用的排序方法</h3><p>插冒归他很稳，插冒归喜欢选冒插，插完他就方了<br>快归堆 n老 </p><h3 id="css选择器及其优先级"><a href="#css选择器及其优先级" class="headerlink" title="css选择器及其优先级"></a>css选择器及其优先级</h3><h3 id="伪类和伪元素的区别和作用"><a href="#伪类和伪元素的区别和作用" class="headerlink" title="伪类和伪元素的区别和作用"></a>伪类和伪元素的区别和作用</h3><p>伪类和伪元素本质上的区别就是有没有生成新的元素<br>伪类：：hover :visited :link<br>伪元素：::after ::before</p><h3 id="对盒模型的理解"><a href="#对盒模型的理解" class="headerlink" title="对盒模型的理解"></a>对盒模型的理解</h3><p>标准盒模型<br>怪异盒模型</p><h3 id="预处理器及其使用原理"><a href="#预处理器及其使用原理" class="headerlink" title="预处理器及其使用原理"></a>预处理器及其使用原理</h3><p>less<br>sass<br>可以减少css重复代码，节省开发时间<br>转换为css时，有良好的格式，易于组织和维护</p><h3 id="CSS代码如何插入"><a href="#CSS代码如何插入" class="headerlink" title="CSS代码如何插入"></a>CSS代码如何插入</h3><p>link引入</p><h3 id="如何实现水平居中"><a href="#如何实现水平居中" class="headerlink" title="如何实现水平居中"></a>如何实现水平居中</h3><h3 id="对媒体查询的理解，使用场景"><a href="#对媒体查询的理解，使用场景" class="headerlink" title="对媒体查询的理解，使用场景"></a>对媒体查询的理解，使用场景</h3><p>响应式开发的时候</p><h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p>浅拷贝只是拷贝了一份栈中的地址，互相影响<br>深拷贝时在堆中为新对象开辟了一个新的内存，两者互不影响</p><h3 id="对this的理解，箭头函数的this"><a href="#对this的理解，箭头函数的this" class="headerlink" title="对this的理解，箭头函数的this"></a>对this的理解，箭头函数的this</h3><p>this永远指向的是他的调用者<br>箭头函数没有自己的this，因为他没有prototype,箭头函数的this指向的是上下文中的this</p><h3 id="如何实现数组去重"><a href="#如何实现数组去重" class="headerlink" title="如何实现数组去重"></a>如何实现数组去重</h3><p>1、new Set(…arr)<br>Array.from(new Set(arr))<br>2、indexof+for循环<br>3、filter+indexof<br>4、forEach+includes</p><h3 id="本地存储的方法"><a href="#本地存储的方法" class="headerlink" title="本地存储的方法"></a>本地存储的方法</h3><p>有三种 cookie localstorage sessionStroage<br><img src="/../img/cookie.png" alt="这是图片" title="Magic Gardens"></p><h3 id="vue响应式原理"><a href="#vue响应式原理" class="headerlink" title="vue响应式原理"></a>vue响应式原理</h3><h3 id="vue2为什么不能监测到数据的变化"><a href="#vue2为什么不能监测到数据的变化" class="headerlink" title="vue2为什么不能监测到数据的变化"></a>vue2为什么不能监测到数据的变化</h3><h3 id="computed和watch的区别"><a href="#computed和watch的区别" class="headerlink" title="computed和watch的区别"></a>computed和watch的区别</h3><h3 id="如何现在有一个数组，检测他的长度变化，使用那个-计算属性就可以"><a href="#如何现在有一个数组，检测他的长度变化，使用那个-计算属性就可以" class="headerlink" title="如何现在有一个数组，检测他的长度变化，使用那个(计算属性就可以)"></a>如何现在有一个数组，检测他的长度变化，使用那个(计算属性就可以)</h3><h3 id="vue的生命周期"><a href="#vue的生命周期" class="headerlink" title="vue的生命周期"></a>vue的生命周期</h3><p>beforeCreat:数据劫持、数据代理未开始，访问不到data中的数据，method中的方法<br>created:数据带、数据劫持开始，可以访问到data中的数据,metods中的方法<br>beforeMount:此时的页面是未经Vue编译的DOM结构，这时对DOM的操作都不奏效<br>mounted:页面上的DOM是经过vue编译的，初始化结束<br>beforeUpdate:数据是新的，但是还没有在页面中展示<br>updated:数据是新的，页面也是新的<br>beforeDestory:此时vue中的data、methods、指令…还处于可用状态，但是数据已经不会再页面展示了<br>destoryed:销毁完成</p><h3 id="keep-alive独特的生命周期"><a href="#keep-alive独特的生命周期" class="headerlink" title="keep-alive独特的生命周期"></a>keep-alive独特的生命周期</h3><p>keep-alive是vue的内置组件，当他包裹动态组件时，会缓存不活动的组件实例，而不是销毁他们。<br>作用：在组建切换过程中将状态保留在内存中，防止重复渲染DOM，减少加载时间以及性能消耗，提高用户体验感<br>独有的生命周期钩子：actived deactivated<br>actived:在keep-alive组件被激活的时候调用，在组件第一次渲染的时候也会被调用，咋hi后每次keep-alive激活时被调用。该狗子在服务器渲染阶段不会被调用<br>deactivated：在keep-alive组件停用时调用，该狗子在服务器渲染阶段不会被调用</p><h3 id="25、data为什么是一个函数而不是一个对象？"><a href="#25、data为什么是一个函数而不是一个对象？" class="headerlink" title="25、data为什么是一个函数而不是一个对象？"></a>25、data为什么是一个函数而不是一个对象？</h3><p>在组件中data必须写成一个函数，这样就可以防止数据污染，如果是一个对象形式，所有的所组件会共用一个data，会造成数据污染，写成函数式，调用的时候返回的都是一个新的data对象，就是说每一个组件都有自己的data，当修改数据的时候，就只是修改了自己身上的数据。</p><h3 id="26、给data中的对象添加一个新的属性会发生什么？如何解决？"><a href="#26、给data中的对象添加一个新的属性会发生什么？如何解决？" class="headerlink" title="26、给data中的对象添加一个新的属性会发生什么？如何解决？"></a>26、给data中的对象添加一个新的属性会发生什么？如何解决？</h3><p>给data中的对象添加一个新属性，数据会更新，但是页面不会更新<br>因为vue2是通过Object.prototype()实现属性的响应式的，但是我们给对象添加新属性是没有通过Object.prototype()，所以没有getter和setter，vue就检测不到<br>解决：1、Vue.set() 向对象中添加一个响应式数据<br>      2、创建一个新对象，通过Object.assgin()，合并原来的对象和混入对象的属性</p><h3 id="27、vue中如何检测数组或对象某个属性的变化（我答重写数组的一些方法？）"><a href="#27、vue中如何检测数组或对象某个属性的变化（我答重写数组的一些方法？）" class="headerlink" title="27、vue中如何检测数组或对象某个属性的变化（我答重写数组的一些方法？）"></a>27、vue中如何检测数组或对象某个属性的变化（我答重写数组的一些方法？）</h3><p>1、先判断这个属性是否原本就存在，如果存在就用setter和getter进行监视，实现数据的实时更新<br>2、如果这个属性原来不存在，就使用vue.set(),将这个属性百年城响应式的，在进行监听</p><h3 id="28、父子组件通信和兄弟组件通信（漏答了vuex，面试官提醒）"><a href="#28、父子组件通信和兄弟组件通信（漏答了vuex，面试官提醒）" class="headerlink" title="28、父子组件通信和兄弟组件通信（漏答了vuex，面试官提醒）"></a>28、父子组件通信和兄弟组件通信（漏答了vuex，面试官提醒）</h3><p>1、props<br>2、全局事件总线<br>3、pubsub-JS 消息发布与订阅<br>4、vuex<br>子传父：ref(父组件可以获取到子组件身上的所有属性和方法)  自定义事件</p><h3 id="29、vue路由的两种模式"><a href="#29、vue路由的两种模式" class="headerlink" title="29、vue路由的两种模式"></a>29、vue路由的两种模式</h3><p>hash 域名的后面带了一个#<br>history</p><h3 id="30、路由传参"><a href="#30、路由传参" class="headerlink" title="30、路由传参"></a>30、路由传参</h3><p>params参数 在路由需要占位<br>query参数</p><h3 id="31、vuex是什么？分为哪四部分？在项目中用过吗？（四部分？没详细分过。。。）"><a href="#31、vuex是什么？分为哪四部分？在项目中用过吗？（四部分？没详细分过。。。）" class="headerlink" title="31、vuex是什么？分为哪四部分？在项目中用过吗？（四部分？没详细分过。。。）"></a>31、vuex是什么？分为哪四部分？在项目中用过吗？（四部分？没详细分过。。。）</h3><p>32、action和mutation的区别？<br>action：这里面可以用于进行一些自己的操作，或者一些异步操作，比如发请求，commit用于提交action<br>mutation：用于修改state里面的数据<br>计网：</p><h3 id="32、常用的请求方法（我说get和post常用点，面试官说四种都挺常用的，因为那个restful-api的要求）"><a href="#32、常用的请求方法（我说get和post常用点，面试官说四种都挺常用的，因为那个restful-api的要求）" class="headerlink" title="32、常用的请求方法（我说get和post常用点，面试官说四种都挺常用的，因为那个restful api的要求）"></a>32、常用的请求方法（我说get和post常用点，面试官说四种都挺常用的，因为那个restful api的要求）</h3><p>get<br>post<br>put<br>delete<br>options</p><h3 id="33、get请求和post请求的区别"><a href="#33、get请求和post请求的区别" class="headerlink" title="33、get请求和post请求的区别"></a>33、get请求和post请求的区别</h3><p>1、url可见性<br>get的url可见，post的url不可见<br>2、参数传递上<br>get通过拼接url传参，post通过body体传参<br>3、数据没有大小<br>get一般传递的不超过2-4k，post没有限制<br>4、缓存性<br>get可以缓存，post没有缓存<br>5、后退页面<br>get没有影响，post要重新发请求<br>6、安全性<br>相比下，post安全，但是有抓包<br>7、数据包<br>get是一个TCP数据包，post是两个TCP数据包<br>get是http header和 data一起发送，响应200返回数据<br>post是先发送header ,服务器响应100 continue，浏览器在发送data,服务器响应200（返回数据）</p><h3 id="34、实际项目中如何发起一个请求，拦截机制是什么？（我答axios，机制没答上来）"><a href="#34、实际项目中如何发起一个请求，拦截机制是什么？（我答axios，机制没答上来）" class="headerlink" title="34、实际项目中如何发起一个请求，拦截机制是什么？（我答axios，机制没答上来）"></a>34、实际项目中如何发起一个请求，拦截机制是什么？（我答axios，机制没答上来）</h3><p>利用axios发请求，利用axios二次封装，在请求拦截器里面写，请求之前要干的事，在响应拦截器里面写响应成功之后要干的事情</p><h3 id="35、常见状态码及返回原因（没答更具体）"><a href="#35、常见状态码及返回原因（没答更具体）" class="headerlink" title="35、常见状态码及返回原因（没答更具体）"></a>35、常见状态码及返回原因（没答更具体）</h3><p>1xx 提示信息<br>2xx 成功<br>200  请求成功，返回数据<br>201  请求成功，因此创建了一个新的资源<br>202 服务器已经收到请求和消息，但是尚未进行处理<br>3xx 重定向<br>4xx 客户端失败<br>403 没有访问权限<br>404 请求的资源不存在<br>5xx 服务器失败<br>500 服务器遇到了不知道如何处理的错误<br>502 无效的响应<br>505 服务器不支持当前的http协议版本</p><h3 id="36、跨域讲一下？如何解决？"><a href="#36、跨域讲一下？如何解决？" class="headerlink" title="36、跨域讲一下？如何解决？"></a>36、跨域讲一下？如何解决？</h3><p>跨域就是基于浏览器同源策略下的一种安全机制<br>协议、端口、域名有一个不一样就会导致跨域<br>解决方案：<br>1、JSONP（仅限于get请求）<br>动态添加script标签，调用服务器提供的js脚本，允许用户传递一个callback参数给服务器，然后服务器返回数据的时候会将这个callback参数作为函数包裹JSON数据</p><p>2、CORS（资源共享跨域）<br>后端在响应头里面加上Access-Control-Allow-Origin即可<br>或者引入第三方库解决跨域<br>3、vue.config.js里面添加devServe配置项，代理跨域<br>4、nginx代理跨域</p><h3 id="常用的git命令？分支处理？"><a href="#常用的git命令？分支处理？" class="headerlink" title="常用的git命令？分支处理？"></a>常用的git命令？分支处理？</h3><p>git clone 克隆到本地<br>git add 新增文件<br>git push<br>git pull<br>git commit 提交文件<br>git status 查看工作区状态<br>git reflog 查看提交记录</p><h3 id="有关列表渲染："><a href="#有关列表渲染：" class="headerlink" title="有关列表渲染："></a>有关列表渲染：</h3><p>面试官：table列数过多的时候，如何渲染处理？<br>我：与长列表渲染类似，用虚拟列表机制。<br>面试官：那出现空白怎么办？<br>我：前后多渲染几列。<br>面试官：那虚拟列表怎么实现？<br>我：监听滚动距离，渲染对应的列。<br>面试官：那每列不定宽，如何知道要渲染哪些列？<br>我：寄（内心os：为什么不设置定宽+溢出隐藏呢？）</p><h3 id="有关分页："><a href="#有关分页：" class="headerlink" title="有关分页："></a>有关分页：</h3><p>面试官：如果是后端分页的情况，用户点击第2页，再点击第3页，再点击第2页，那么最后页面渲染的是第2页。但<br>是发起了三次请求，如何处理？<br>我：按钮做一个防抖处理。<br>面试官：防抖实际上并没有规避该类问题，有时还会导致用户的体验问题，并不是一种好的解决方案，还有什么其他<br>解决方案嘛？<br>我：用axios的拦截？（答不上来）<br>面试官：用axios的xx（忘了）</p><h3 id="有关取消按钮："><a href="#有关取消按钮：" class="headerlink" title="有关取消按钮："></a>有关取消按钮：</h3><p>面试官：用户编辑某个表单信息，但之后又取消了，如何使渲染的数据为编辑前的数据？<br>我：表示疑惑？不是必须保存后向后台发起请求并返回成功才能使渲染的数据发生变化吗？<br>面试官：你可能没理解我意思，我指的是不刷新的情况的。换个说法，渲染的数据是响应式的，你编辑了，但是又取<br>消了，这时候怎么办？<br>我：编辑前先深拷贝一份，取消编辑后使渲染的数据变成拷贝的值？<br>4、八股文：</p><h3 id="听说过或者使用过Vue-的-nextTick吗？讲一下原理和应用场景。"><a href="#听说过或者使用过Vue-的-nextTick吗？讲一下原理和应用场景。" class="headerlink" title="听说过或者使用过Vue 的 nextTick吗？讲一下原理和应用场景。"></a>听说过或者使用过Vue 的 nextTick吗？讲一下原理和应用场景。</h3><p>就是等待下一次DOM更新刷新的工具方法，就是放在$nextTick当中的操作不会立即执行，而是等数据更新，DOM更新完成以后在执行，这样我们拿到的就是最新的。<br>vue中的nextTick()方法主要用于处理数据动态变化后，DOM还未及时更新的问题，用nextTick()可以获取数据更新后最新的DOM变化<br>使用场景：<br>1、created中想要获取DOM时，就要把相关的代码放在nextTick()的回调中，因为在created钩子中，DOM还未进行任何的渲染，此时对DOM的操作是没有用的。<br>2、响应式数据变化后获取DOM更新后的状态，比如希望获取列表更新后高度</p><h3 id="那事件循环你是怎么理解的？原理机制讲一下。（面试官说点到了意思，但不是很清晰）"><a href="#那事件循环你是怎么理解的？原理机制讲一下。（面试官说点到了意思，但不是很清晰）" class="headerlink" title="那事件循环你是怎么理解的？原理机制讲一下。（面试官说点到了意思，但不是很清晰）"></a>那事件循环你是怎么理解的？原理机制讲一下。（面试官说点到了意思，但不是很清晰）</h3><p>Event loop 事件循环，是解决js单线程运行的阻塞的一种机制<br>栈在js中成为执行栈，是一种后进先出的数组结构，js有一个主线程和执行栈，主线程的任务都会放在执行栈等在主线程执行<br>任务队列：是一种先进先出的数据结构<br>js是单线程的，单线程就意味着所有的任务都需要排队，前一个任务就必须执行结束，下一个任务才会执行，如果前一个任务执行的时间很长就会阻塞下一个任务，下一个任务必须等待。所以js的任务分为了：同步任务和异步任务<br>js代码在运行的过程中，先运行执行栈中的同步任务，等到同步任务执行完了之后，再去任务队列里面执行异步任务，<br>所有的任务被分为：宏任务和微任务<br>宏任务：script全部代码、setTimeout、setInterval、setTimemediate等<br>微任务：nextTick、Promise.then Object.observe等<br>js引擎会将所有的任务按照这个分类分到这两个队列中，周现在宏任务队列中去除第一个任务，执行完了之后去除微任务队列中所有的任务，按顺序执行，之后再取宏任务，周而复始，直到任务都取完。</p><h3 id="说一下你知道的设计模式？"><a href="#说一下你知道的设计模式？" class="headerlink" title="说一下你知道的设计模式？"></a>说一下你知道的设计模式？</h3><p>原型模式、单列模式、工厂方法模式、抽象工厂模式、代理模式、观察者模式、责任链模式，组合模式</p><h3 id="eventBus是什么设计模式？"><a href="#eventBus是什么设计模式？" class="headerlink" title="eventBus是什么设计模式？"></a>eventBus是什么设计模式？</h3><p>全局事件总线：是消息传递的一种，基于一个消息中心，订阅消息和发布消息的模式<br>this.$bus.emit()发布消息<br>this.$bus.on() 接收消息</p><p>5、手写题：</p><h3 id="手写数组的map方法"><a href="#手写数组的map方法" class="headerlink" title="手写数组的map方法"></a>手写数组的map方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给array的原型上面加上这个属性</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">fakeMap</span> = <span class="keyword">function</span> (<span class="params">fn, context</span>) &#123;</span><br><span class="line">    <span class="comment">// console.log(this) this就指向了数组</span></span><br><span class="line">    <span class="keyword">let</span> temp = []</span><br><span class="line">    <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(<span class="variable language_">this</span>)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;this is not an array&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> callback !== <span class="string">&#x27;function&#x27;</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;this is not an funcion&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> temp</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> res = fn.<span class="title function_">call</span>(context, arr[i], i, arr)</span><br><span class="line">        <span class="comment">// obj1.(method).call(obj2,argument1,argument2) 如上，call的作用就是把obj1的方法放到obj2上使用，</span></span><br><span class="line">        <span class="comment">// call：调用一个对象的一个方法，以另一个对象替换当前的对象</span></span><br><span class="line">        temp.<span class="title function_">push</span>(res)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数组的map方法，需要传入两个参数，第一个是回调函数，第二个是回调函数this的指向</span></span><br><span class="line"><span class="comment">// 注意点：1、回调函数必须是一个函数</span></span><br><span class="line"><span class="comment">//    2、调用该方法的对象必须是一个数组</span></span><br><span class="line"><span class="comment">// 3、如果数组的大小为0 ，则返回空数组</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">arr.<span class="title function_">fakeMap</span>()</span><br></pre></td></tr></table></figure><h3 id="手写eventBus，由于时间关系，讲一下on，emit，off三个方法的实现思路即可。（寄，啥玩意）"><a href="#手写eventBus，由于时间关系，讲一下on，emit，off三个方法的实现思路即可。（寄，啥玩意）" class="headerlink" title="手写eventBus，由于时间关系，讲一下on，emit，off三个方法的实现思路即可。（寄，啥玩意）"></a>手写eventBus，由于时间关系，讲一下on，emit，off三个方法的实现思路即可。（寄，啥玩意）</h3><p>全局事件总线<br>this.$bus.emit() 发布消息<br>this.$bus.on() 接收消息<br>this.$bus.off() 解绑事件</p><h3 id="前端三件套各自的作用？"><a href="#前端三件套各自的作用？" class="headerlink" title="前端三件套各自的作用？"></a>前端三件套各自的作用？</h3><p>html结构 css样式 js交互</p><h3 id="一定要js才能实现交互嘛？"><a href="#一定要js才能实现交互嘛？" class="headerlink" title="一定要js才能实现交互嘛？"></a>一定要js才能实现交互嘛？</h3><h3 id="CSS实现动画的方式，并具体描述一下"><a href="#CSS实现动画的方式，并具体描述一下" class="headerlink" title="CSS实现动画的方式，并具体描述一下"></a>CSS实现动画的方式，并具体描述一下</h3><p>transition 过渡动画（谁要过度就给谁加）<br>transform 转变动画 ：rotate旋转 scale缩放 translate移动<br>animation 关键帧动画 用@keyframes定义关键帧</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> rotate&#123;</span><br><span class="line">  <span class="selector-tag">from</span>&#123;</span><br><span class="line">    <span class="attribute">transform</span>:<span class="built_in">rotate</span>(<span class="number">0deg</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">to</span>&#123;</span><br><span class="line">    <span class="attribute">transform</span>:<span class="built_in">rotate</span>(<span class="number">360deg</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@keyframes</span> rotate&#123;</span><br><span class="line">  <span class="number">0%</span>&#123;</span><br><span class="line">    <span class="attribute">transform</span>:<span class="built_in">rotate</span>(<span class="number">0deg</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">50%</span>&#123;</span><br><span class="line">    <span class="attribute">transform</span>:<span class="built_in">rotate</span>(<span class="number">180deg</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="number">100%</span>&#123;</span><br><span class="line">    <span class="attribute">transform</span>:<span class="built_in">rotate</span>(<span class="number">360deg</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="js实现动画的方式，讲讲过程（延时器-js控制样式）"><a href="#js实现动画的方式，讲讲过程（延时器-js控制样式）" class="headerlink" title="js实现动画的方式，讲讲过程（延时器+js控制样式）"></a>js实现动画的方式，讲讲过程（延时器+js控制样式）</h3><p>利用setInterval控制动画的位移量，来实现匀速动画和缓慢减速动画（缓动动画）</p><h3 id="setTimeout和setInterval区别是什么？它们一定能按照预定时间执行嘛？（我答可能会产生阻塞，面试官问什么阻塞，答不上来了。。。）"><a href="#setTimeout和setInterval区别是什么？它们一定能按照预定时间执行嘛？（我答可能会产生阻塞，面试官问什么阻塞，答不上来了。。。）" class="headerlink" title="setTimeout和setInterval区别是什么？它们一定能按照预定时间执行嘛？（我答可能会产生阻塞，面试官问什么阻塞，答不上来了。。。）"></a>setTimeout和setInterval区别是什么？它们一定能按照预定时间执行嘛？（我答可能会产生阻塞，面试官问什么阻塞，答不上来了。。。）</h3><p>setTimeout，一段时间之后执行一次，然后就不执行了<br>setInterval，每隔一段时间就执行一次，它是一种重复的调用，可能会造成页面阻塞<br>setInterval是一个异步操作，与服务器产生交互，网络延时问题等原因会造成阻塞，setInterval不会因此放慢请求，反而仍会定时发起请求，造成请求过多阻塞</p><h3 id="js事件循环知道嘛？事件队列又是什么？"><a href="#js事件循环知道嘛？事件队列又是什么？" class="headerlink" title="js事件循环知道嘛？事件队列又是什么？"></a>js事件循环知道嘛？事件队列又是什么？</h3><p>9、微任务与宏任务概念及例子讲一下<br>宏任务：定时器，ajax请求、事件绑定等<br>微任务：Promise.then await Generator中的yeild  Promise本身不会异步</p><h3 id="promise是什么，方法有哪些？"><a href="#promise是什么，方法有哪些？" class="headerlink" title="promise是什么，方法有哪些？"></a>promise是什么，方法有哪些？</h3><p>Promise是异步编程的一种解决方案<br>方法：then catch all finally  reslove reject </p><h3 id="promise-all和promise-race的区别"><a href="#promise-all和promise-race的区别" class="headerlink" title="promise.all和promise.race的区别"></a>promise.all和promise.race的区别</h3><pre><code>Promise.all([...]) 同时返回多个Promise的执行结果,其中有一个错，就返回错误，返回的数组里面就是得到的数据Promise.race([...]) 返回执行最快的Promise,不考虑对错，都返回</code></pre><h3 id="async和await是什么，实现机制是什么？用同步的方式，实现异步"><a href="#async和await是什么，实现机制是什么？用同步的方式，实现异步" class="headerlink" title="async和await是什么，实现机制是什么？用同步的方式，实现异步"></a>async和await是什么，实现机制是什么？用同步的方式，实现异步</h3><p>async作为一个关键字放在函数前面，表示该方法是一个异步函数，异步函数意味着该函数的执行不会阻塞后面的代码，<br>await用于等待一个异步方法执行完成。<br>async和await的作用就是使异步操作以同步的方式去执行。<br>async 函数返回的是一个promise 对象，并且Promise还有state和result，如果async函数中有返回值，当调用该函数时，内部会调用Promise.resolve()方法把它转化成一个promise对象作为返回，但如果timeout函数内部抛出错误呢？ 那么就会调用Promise.reject() 返回一个promise 对象<br>通过async定义的函数返回的是一个Promise对象</p><h3 id="讲一下闭包"><a href="#讲一下闭包" class="headerlink" title="讲一下闭包"></a>讲一下闭包</h3><p>闭包就是有权访问另一函数作用域中的变量的函数<br>特点：1、让外部访问函数内部变量变成了可能<br>      2、变量会常驻内存<br>      3、可以避免使用全局变量，防止全局变量污染<br>好处：可以读取到其他函数内部的变量，并将其一直存放在内存中<br>坏处：可能会造成内存泄漏或溢出</p><p>14、ES6新增的属性有哪些<br>15、箭头函数与普通函数的区别？<br>16、讲一下this<br>17、vue双向数据绑定的原理<br>18、vue的生命周期<br>19、介绍一下项目</p><h3 id="删除用户是软删除还是硬删除？"><a href="#删除用户是软删除还是硬删除？" class="headerlink" title="删除用户是软删除还是硬删除？"></a>删除用户是软删除还是硬删除？</h3><p>硬删除：完全删除，查询不到<br>软删除：只是设置了一个字段，信息看还可以恢复</p><p>5、解决跨域的方式还有哪些？<br>6、用Vue2还是Vue3多一点，擅长哪个？<br>7、Vue2的选项式API和Vue3的组合式API各有什么缺点？<br>8、data为什么是一个函数而不是一个对象？</p><h3 id="讲一下Vue中逻辑复用怎么实现？"><a href="#讲一下Vue中逻辑复用怎么实现？" class="headerlink" title="讲一下Vue中逻辑复用怎么实现？"></a>讲一下Vue中逻辑复用怎么实现？</h3><p>组件复用 v-slot<br>逻辑复用：mixin混入,可以将一些相同的方法，逻辑单独领出来，然后使用的时候直接引入mixin,调用</p><p>10、说一下Vue的生命周期？</p><h3 id="一般在哪个生命周期请求异步数据？"><a href="#一般在哪个生命周期请求异步数据？" class="headerlink" title="一般在哪个生命周期请求异步数据？"></a>一般在哪个生命周期请求异步数据？</h3><p>created&#x2F;mounted&#x2F;beforemount,因为这个时候已经有数据了</p><p>12、组件通信的方式有哪些？<br>13、路由有哪些模式？</p><h3 id="Vue中key的作用？"><a href="#Vue中key的作用？" class="headerlink" title="Vue中key的作用？"></a>Vue中key的作用？</h3><p>key是虚拟DOM对象的标识，当数据放生变化的时候，vue就会根据新数据产生新的虚拟DOM，随后vue就会进行新旧虚拟DOM的差异对比。<br>如果和之前的一样就沿用，如果不一样就生成新的虚拟DOM，随后就替换掉页面中的旧的真实的DOM</p><h3 id="为什么要用虚拟dom？"><a href="#为什么要用虚拟dom？" class="headerlink" title="为什么要用虚拟dom？"></a>为什么要用虚拟dom？</h3><p>虚拟DOM其实就是一层对真实DOM的抽象，以JS作为基础的树，用对象的属性来描述节点，然后经过一些列的操作，是这棵树映射到真实的环境中<br>创建虚拟ODM就是为了更好的将虚拟DOM的节点渲染到页面视图中<br>DOM是很慢的，其元素非常的庞大，页面的性能问题大多都是由DOM操作引起的<br>虚拟DOM的好处：<br>1、比真实的DOM体积小，操作相对来说，消耗的性能比较少，如果在页面上删除一个DOM，会引起重回，影响后面的页面，虚拟DOM不会进行回流和重回。<br>2、虚拟DOM进行频繁的修改，然后一次性比较并修改真实DOM中需要修改的部分被，最后在真实DOM中进行重回和回流，减少过多的DOM节点的回流和重回，真实DOM频繁的回流和重绘会导致效率非常低。<br>16、ES6新增的属性有哪些？<br>17、let，const，var的区别？<br>18、箭头函数与普通函数的区别？</p><h3 id="手写：将英文句子各个单词首字母大写输出"><a href="#手写：将英文句子各个单词首字母大写输出" class="headerlink" title="手写：将英文句子各个单词首字母大写输出"></a>手写：将英文句子各个单词首字母大写输出</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先将字符串分割成数组split</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">strToCase</span>(<span class="params">str</span>)&#123;</span><br><span class="line"> <span class="keyword">let</span> str= str.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"> <span class="comment">//遍历数组的每一项</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;str.<span class="property">length</span>;i++)&#123;</span><br><span class="line">  str[i]=str[i].<span class="title function_">split</span>(<span class="number">0</span>,<span class="number">1</span>).<span class="title function_">toUpperCase</span>()+str[i].<span class="title function_">split</span>(<span class="number">1</span>).<span class="title function_">toLowerCase</span>()</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="手写：统计字符串各个元素的个数"><a href="#手写：统计字符串各个元素的个数" class="headerlink" title="手写：统计字符串各个元素的个数"></a>手写：统计字符串各个元素的个数</h3><p>1、先将字符串中的元素都变成小写的<br>2、创建一个空对象，用来存储遍历的元素<br>3、当对象中没有该元素时，添加并赋值为1，对象中有时，就给他的值加一<br>4、遍历这个对象，或者直接输出这个对象</p><h3 id="项目中的登录功能是如何实现的？具体说一下"><a href="#项目中的登录功能是如何实现的？具体说一下" class="headerlink" title="项目中的登录功能是如何实现的？具体说一下"></a>项目中的登录功能是如何实现的？具体说一下</h3><p>在登陆页面输入用户名和密码<br>点击登录调用后台接口进行验证，通过验证之后，后台会生成该用户的token并返回。客服端存储token<br>然后后续所有的请求都要携带token发送请求，服务端验证用户token是否通过<br>通过验证之后，根据后台的响应状态跳转到首页<br>发送请求，然后先判断本地里面有没有token,有就直接调用，没有的话，服务器就会返回一个token<br>8、用过git嘛？说一下用过的git命令？</p><h3 id="node环境与浏览器环境有什么区别？"><a href="#node环境与浏览器环境有什么区别？" class="headerlink" title="node环境与浏览器环境有什么区别？"></a>node环境与浏览器环境有什么区别？</h3><p>1、浏览器和node.js都可以看做是js的运行平台，浏览器是js在客户端运行，node.js是js在服务端运行<br>2、js运行在服务端，用于用户的交互效果。js运行在node.js，用于服务器的操作<br>3、js需要浏览器的js引擎进行解析执行，但是不同的浏览器的js引擎是不同的，存在兼容问题。而node.js是基于chrome v8引擎的运行环境，无兼容性的问题。<br>4、对于ES语法来说，在node.js和浏览器中都能运行。node.js无法使用DOM和BOM的操作，浏览器无法执行Node.js中文件操作等功能。<br>5、浏览器下this指向的是window,node.js中this指向的是global<br>6、使用的模块标准不同，node.js使用的是CommonJS的模块标准，而浏览器使用的是ES的模块标准，node.js中是使用require()导入模块，浏览器中使用的是import的方式导入。</p><h3 id="对V8引擎了解哪些内容？"><a href="#对V8引擎了解哪些内容？" class="headerlink" title="对V8引擎了解哪些内容？"></a>对V8引擎了解哪些内容？</h3><pre><code>V8 是 Google 开源的 JavaScript 引擎。可以理解为：V8 将程序员写的代码，最终解析成机器码能够让计算机识别。其中的具体操作，就是 V8 干的事。我们把 V8 看成一个黑盒， 程序语言进去，通过黑盒子的处理，经过一系列操作后，解析成机器码。【V8被广泛用于各种JavaScript执行环境。】了解V8，对于性能优化的思考会有更多理解和方向。能够更轻松理解babel语法分析原理，eslint语法检查机制，前端框架的底层实现。</code></pre><p><img src="/../img/v8.png" alt="这是图片" title="Magic Gardens"><br>加入了编译器「lgnition」，用来引入了字节码，达到减少内存使用的目的。</p><h6 id="V8-引擎的运行过程："><a href="#V8-引擎的运行过程：" class="headerlink" title="V8 引擎的运行过程："></a>V8 引擎的运行过程：</h6><p>首先通过解析器「Parser」将 JavaScript 解析成 AST，<br>然后解释器「lgnition」会将AST翻译成字节码。此阶段边解释边执行。同时解释器「lgnition」会记录特定代码段的执行次数，当运行次数达到一定值「称为阈值」，解释器「lgnition」就会将该段代码标记为热代码，并将信息反馈给优化编译器「TurboFan」。<br>优化编译器「TurboFan」会对标记的代码段进行优化，最终生成优化后的字节码。这样当该段代码需要再次执行时，就会直接使用优化后的机器码执行，不用再进行解释编译。从而大大提高代码运行效率。</p><h6 id="V8的解析过程："><a href="#V8的解析过程：" class="headerlink" title="V8的解析过程："></a>V8的解析过程：</h6><p>V8 只有等编译完成后才能运行代码。所以解析和编译过程的性能很重要。V8 的整个解析过程分两个部分：词法分析和语法分析。<br><img src="/../img/v81.png" alt="这是图片" title="Magic Gardens"></p><p>词法分析：将字符流「即一行行的代码」转换为 tokens「即不能再分割的最小单位，可能是单个字符，也可能是字符串」。<br>语法分析：根据语法规则，将 tokens 组成一个有嵌套层级的抽象语法结构树「即 AST」，在此过程中，如果源码不符合语法规范，解析过程就会终止，并抛出语法错误。图中的 Parser 和 Pre-Parser 都是 V8 的语法分析器。<br>如果一次性全部解析出来所有代码，会占用磁盘空间，也非常消耗内存，并且执行的时间会很长。<br>所以存在预解析，比如当词法分析阶段读到函数声明时，因为函数不需要立即执行，所以会进行预解析。「即只解析函数声明，不解析函数内部的代码，不会为函数生成AST」。 Pre-Parser 就是用来预解析的。当函数调用的时候才会真正开始解析生成AST。最终会将AST转成字节码。</p><h3 id="说一下V8引擎的垃圾回收机制"><a href="#说一下V8引擎的垃圾回收机制" class="headerlink" title="说一下V8引擎的垃圾回收机制"></a>说一下V8引擎的垃圾回收机制</h3><p>v8 的垃圾回收机制基于分代回收机制，这个机制又基于世代假说，这个假说有两个特点，一是新生的对象容易早死，另一个是不死的对象会活得更久。基于这个假说，v8 引擎将内存分为了新生代和老生代。<br>新创建的对象或者只经历过一次的垃圾回收的对象被称为新生代。经历过多次垃圾回收的对象被称为老生代。<br>新生代被分为 From 和 To 两个空间，To 一般是闲置的。当 From 空间满了的时候会执行 Scavenge 算法进行垃圾回收。当我们执行垃圾回收算法的时候应用逻辑将会停止，等垃圾回收结束后再继续执行。这个算法分为三步：<br>（1）首先检查 From 空间的存活对象，如果对象存活则判断对象是否满足晋升到老生代的条件，如果满足条件则晋升到老生代。如果不满足条件则移动 To 空间。<br>（2）如果对象不存活，则释放对象的空间。<br>（3）最后将 From 空间和 To 空间角色进行交换。<br>新生代对象晋升到老生代有两个条件：<br>（1）第一个是判断是对象否已经经过一次 Scavenge 回收。若经历过，则将对象从 From 空间复制到老生代中；若没有经历，则复制到 To 空间。<br>（2）第二个是 To 空间的内存使用占比是否超过限制。当对象从 From 空间复制到 To 空间时，若 To 空间使用超过 25%，则对象直接晋升到老生代中。设置 25% 的原因主要是因为算法结束后，两个空间结束后会交换位置，如果 To 空间的内存太小，会影响后续的内存分配。<br>老生代采用了标记清除法和标记压缩法。标记清除法首先会对内存中存活的对象进行标记，标记结束后清除掉那些没有标记的对象。由于标记清除后会造成很多的内存碎片，不便于后面的内存分配。所以了解决内存碎片的问题引入了标记压缩法。<br>由于在进行垃圾回收的时候会暂停应用的逻辑，对于新生代方法由于内存小，每次停顿的时间不会太长，但对于老生代来说每次垃圾回收的时间长，停顿会造成很大的影响。 为了解决这个问题 V8 引入了增量标记的方法，将一次停顿进行的过程分为了多步，每次执行完一小步就让运行逻辑执行一会，就这样交替运行。</p><h3 id="说一下js的事件循环机制"><a href="#说一下js的事件循环机制" class="headerlink" title="说一下js的事件循环机制"></a>说一下js的事件循环机制</h3><p>JavaScript是一门单线程语言<br>分为同步任务和异步任务<br>同步任务是指在主线程上排队执行的任务，只有前一个任务执行完毕，才能继续执行下一个任务。<br>异步任务指的是，不进入主线程、而进入”任务队列”的任务；只有等主线程任务全部执行完毕，”任务队列”的任务才会进入主线程执行。</p><p>执行过程: 同步任务 —&gt; 微任务 —&gt; 宏任务<br>1.先执行所有同步任务，碰到异步任务放到任务队列中<br>2.同步任务执行完毕，开始执行当前所有的异步任务<br>3.先执行任务队列里面所有的微任务<br>4.然后执行一个宏任务<br>5.然后再执行所有的微任务<br>6.再执行一个宏任务，再执行所有的微任务·······依次类推到执行结束。<br>3-6的这个循环称为事件循环Event Loop<br>事件循环是JavaScript实现异步的一种方法，也是JavaScript的执行机制</p><p>14、说一下CSS中的盒模型</p><h3 id="let与var、const定义变量的区别？"><a href="#let与var、const定义变量的区别？" class="headerlink" title="let与var、const定义变量的区别？"></a>let与var、const定义变量的区别？</h3><p>1、var声明的变量属于函数作用域，而let和const声明的变量属于块级作用域；<br>2、var声明的变量存在变量提升，而let和const没有<br>3、var声明的变量可以重复声明，而在同一块级作用域，let变量不能重新声明，const常量不能修改（对象的属性和方法，数组的内容可以修改）</p><h3 id="如果程序中所有值不变的变量都用const定义，会发生什么问题？"><a href="#如果程序中所有值不变的变量都用const定义，会发生什么问题？" class="headerlink" title="如果程序中所有值不变的变量都用const定义，会发生什么问题？"></a>如果程序中所有值不变的变量都用const定义，会发生什么问题？</h3><p>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。<br>对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。<br>但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p><p>17、说一下Vue组件通信的方式？<br>18、操作系统中的换页算法有哪些？机制是什么？<br>19、32位操作系统和64位操作系统分别是什么意思，它们各自的寻址范围和内存空间是多少？<br>20、后端向前端传输一张图片时，说一下其中的机制或者过程？（TCP连接，三次握手、四次挥手？）</p><h3 id="TCP和UDP的区别？"><a href="#TCP和UDP的区别？" class="headerlink" title="TCP和UDP的区别？"></a>TCP和UDP的区别？</h3><p>TCP面向连接，通过三次握手建立连接，四次挥手接除连接;UDP是无连接的，即发送数据之前不需要建立连接，这种方式为UDP带来了高效的传输效率，但也导致无法确保数据的发送成功。<br>TCP是可靠的通信方式。通过TCP连接传送的数据，TCP通过超时重传、 数据校验等方式来确保数据无差错，不丢失，不重复，且按序到达；而UDP由于无需连接的原因，将会以最大速度进行传输，但不保证可靠交付，也就是会出现丢失、重复等等问题。<br>TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流，由于连接的问题，当网络出现波动时，连接可能出现响应问题；UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低。<br>每一条TCP连接只能是点到点的；而UDP不建立连接，所以可以支持一对一，一对多，多对一和多对多的交互通信，也就是可以同时接受多个人的包。<br>TCP需要建立连接，首部开销20字节相比8个字节的UDP显得比较大。<br>TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道。</p><h3 id="20级台阶，青蛙每次只能跳1阶或者两阶，有多少种跳法？（利用递归）"><a href="#20级台阶，青蛙每次只能跳1阶或者两阶，有多少种跳法？（利用递归）" class="headerlink" title="20级台阶，青蛙每次只能跳1阶或者两阶，有多少种跳法？（利用递归）"></a>20级台阶，青蛙每次只能跳1阶或者两阶，有多少种跳法？（利用递归）</h3><p>当floor&#x3D;1时，有一种方法<br>当floor&#x3D;2时，由两种方法<br>当floor&#x3D;3时，第一次跳1层，还剩两层 有两种方法<br>             当第一次跳2层，还剩一层，有一种方法<br>当floor&#x3D;4时，第一次跳1层，还剩3层 调用第三层的方法   jumpFloor(4-1)+jumpFloor(4-2)<br>              当第一次跳2层，还剩2层，调用第2层的方法    </p><h3 id="如果用户进入一个路由，但是没有登陆，那么跳转到登录页面并登录后如何进到该路由？"><a href="#如果用户进入一个路由，但是没有登陆，那么跳转到登录页面并登录后如何进到该路由？" class="headerlink" title="如果用户进入一个路由，但是没有登陆，那么跳转到登录页面并登录后如何进到该路由？"></a>如果用户进入一个路由，但是没有登陆，那么跳转到登录页面并登录后如何进到该路由？</h3><p>（我答缓存路由，面试官说考察路由重定向，把路由通过login页面传进去）<br>当用户访问一个路由，但是没有登录，有些路由用户没有访问权限，然后就会重定向到登录页面，在用户登录成功之后，就把路由通过login页面传进去<br><img src="/../img/route.png" alt="这是图片" title="Magic Gardens"></p><h3 id="如何实现七天内免登录进入？"><a href="#如何实现七天内免登录进入？" class="headerlink" title="如何实现七天内免登录进入？"></a>如何实现七天内免登录进入？</h3><p>（我答通过缓存+路由守卫，面试官说直接本地存储用户信息不安全，结合token实现。）<br>使用token,登陆的时候先获取token（用户的令牌），点击登录，就会在本地缓存里面看有没有token，如果有，纠结爹带着，如果没有服务器就返回一个token，然后以后用户每一次进行路由跳转的时候，都要用这个token来判断，是否可以跳转成功。<br>获取本地缓存里面token,得到用户上一次登陆的时间，判断上一次登陆的时间加上七天的时间和现在登录使时间（时间戳）<br>time&#x3D;1000<em>60</em>60<em>24</em>7 七天的时间戳<br>sunTime&#x3D;之前登录的时间戳+七天的时间戳<br>oldTime&#x3D;之前登录的时间戳<br>newTime:现在登陆的时间戳<br>if(现在登陆的时间戳&gt;之前登录的时间戳+七天的时间戳)就返回登录页面（登录已经超过七天）<br>if（没有超过），就直接到首页，表示登陆成功</p><h3 id="表单如果不知道全部数据，如何实现分页？"><a href="#表单如果不知道全部数据，如何实现分页？" class="headerlink" title="表单如果不知道全部数据，如何实现分页？"></a>表单如果不知道全部数据，如何实现分页？</h3><p>（刚开始没get到点，后来面试官说结合懒加载的思想，看当前页是否已满，如果未满说明没有下一页了，已满则可以发起请求）</p><h4 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h4><p>懒加载叫做延迟加载、按需加载，指的是在长网页中延迟加载图片数据，是一种比较好的网页性能优化的方式。在较长的网页或应用中，如果图片很多，所有的图片都被加载出来，而用户只能看到可是窗口的一部分图片数据，这样就浪费了性能。<br>如果使用图片的懒加载就可以解决以上问题。在滚动屏幕之前，可视化区域之外的图片就不会进行中加载，在滚动屏幕时才被加载，这样使得网页的加载速度变得更快，减轻服务器的负载。懒加载适用于图片较多，页面列表较长的场景使用。</p><h4 id="懒加载的特点"><a href="#懒加载的特点" class="headerlink" title="懒加载的特点"></a>懒加载的特点</h4><p>1、减轻无用资源的加载：使用懒加载明显减少了服务器的压力和流量，同时减少了浏览器的负担。<br>2、提升用户体验感：如果同时加载较多的图片，可能需要等待的时间较长，这样影响了用户体验，而使用懒加载就能大大提高用户的体验。<br>3、防止加载过多的图片而影响其他资源文件的加载：会影响网站应用的正常使用</p><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>图片的加载是由src引起的，当对src赋值时，浏览器就会请求图片资源。根据这个原理，我们使用HTML5 的data-xxx属性来储存图片的路径，在需要加载图片的时候，将data-xxx中图片的路径赋值给src，这样就实现了图片的按需加载，即懒加载。</p><p>注意：data-xxx 中的xxx可以自定义，这里我们使用data-src来定义。</p><p>懒加载的实现重点就是在于确认用户需要加载那张图片，在浏览器中，可视区域内的资源就是用户需要的资源，所以当图片出现在可视区域的时候，就要获取图片真实的地址并赋值给图片即可。</p><h4 id="使用原生JavaScript实现懒加载："><a href="#使用原生JavaScript实现懒加载：" class="headerlink" title="使用原生JavaScript实现懒加载："></a>使用原生JavaScript实现懒加载：</h4><p>知识点：</p><p>（1）window.innerHeight 是浏览器可视区的高度</p><p>（2）document.body.scrollTop || document.documentElement.scrollTop 是浏览器滚动过的距离</p><p>（3）imgs.offsetTop 是元素顶部距离文档顶部的高度（包括滚动条的距离）</p><p>（4）图片加载条件：img.offsetTop &lt; window.innerHeight + document.body.scrollTop;</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;loading.gif&quot;</span>  <span class="attr">data-src</span>=<span class="string">&quot;pic.png&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;loading.gif&quot;</span>  <span class="attr">data-src</span>=<span class="string">&quot;pic.png&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;loading.gif&quot;</span>  <span class="attr">data-src</span>=<span class="string">&quot;pic.png&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;loading.gif&quot;</span>  <span class="attr">data-src</span>=<span class="string">&quot;pic.png&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;loading.gif&quot;</span>  <span class="attr">data-src</span>=<span class="string">&quot;pic.png&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;loading.gif&quot;</span>  <span class="attr">data-src</span>=<span class="string">&quot;pic.png&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> imgs = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;img&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">function</span> <span class="title function_">lozyLoad</span>(<span class="params"></span>)&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> scrollTop = <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">scrollTop</span> || <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">scrollTop</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> winHeight= <span class="variable language_">window</span>.<span class="property">innerHeight</span>;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i &lt; imgs.<span class="property">length</span>;i++)&#123;</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">if</span>(imgs[i].<span class="property">offsetTop</span> &lt; scrollTop + winHeight )&#123;</span></span><br><span class="line"><span class="language-javascript">imgs[i].<span class="property">src</span> = imgs[i].<span class="title function_">getAttribute</span>(<span class="string">&#x27;data-src&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="property">onscroll</span> = <span class="title function_">lozyLoad</span>();</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><h4 id="懒加载与预加载的区别"><a href="#懒加载与预加载的区别" class="headerlink" title="懒加载与预加载的区别"></a>懒加载与预加载的区别</h4><p>这两种方式都是提高网页性能的方式，两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。</p><p>懒加载也叫延迟加载，指的是在长网页中延迟加载图片的时机，当用户需要访问时，再去加载，这样可以提高网站的首屏加载速度，提升用户的体验，并且可以减少服务器的压力。它适用于图片很多，页面很长的电商网站的场景。懒加载的实现原理是，将页面上的图片的 src 属性设置为空字符串，将图片的真实路径保存在一个自定义属性中，当页面滚动的时候，进行判断，如果图片进入页面可视区域内，则从自定义属性中取出真实路径赋值给图片的 src 属性，以此来实现图片的延迟加载。<br>预加载指的是将所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。 通过预加载能够减少用户的等待时间，提高用户的体验。我了解的预加载的最常用的方式是使用 js 中的 image 对象，通过为 image 对象来设置 scr 属性，来实现图片的预加载。</p><p>3、一些八股：</p><h3 id="说一下CSS的优先级"><a href="#说一下CSS的优先级" class="headerlink" title="说一下CSS的优先级"></a>说一下CSS的优先级</h3><p>权重记忆口诀：从0开始，一个行内样式+1000，一个id选择器+100，一个属性选择器、class或者伪类+10，一个元素选择器，或者伪元素+1，通配符+0。<br>常用选择器权重优先级：!important &gt; id &gt; class &gt; tag<br>!important可以提升样式优先级，但不建议使用。如果!important被用于一个简写的样式属性，那么这条简写的样式属性所代表的子属性都会被应用上!important。 例如：background: blue !important;<br>如果两条样式都使用!important，则权重值高的优先级更高<br>在css样式表中，同一个CSS样式你写了两次，后面的会覆盖前面的<br>样式指向同一元素，权重规则生效，权重大的被应用<br>样式指向同一元素，权重规则生效，权重相同时，就近原则生效，后面定义的被应用<br>样式不指向同一元素时，权重规则失效，就近原则生效，离目标元素最近的样式被应用</p><p>3-2、如何实现垂直水平居中</p><h3 id="页面渲染时，资源加载的顺序是什么？"><a href="#页面渲染时，资源加载的顺序是什么？" class="headerlink" title="页面渲染时，资源加载的顺序是什么？"></a>页面渲染时，资源加载的顺序是什么？</h3><p>解析html以构建dom树-&gt;构建render树-&gt;布局render树-&gt;绘制render树<br>1.一个页面的加载顺序是从上到下顺序加载的，并且加载与渲染同时进行。<br>渲染引擎所做的事是将请求内容展现给我们,<br>构建DOM树<br>构建CSSOM树<br>解析js代码<br>根据DOM树和CSSOM树，生成渲染树<br>根据渲染树，将节点数的每一个节点布局在屏幕上的正确位置<br>遍历渲染树的所有节点，为每一个节点使用对应的样式。<br>1.构建DOM树(DOM tree)：从上到下解析HTML文档生成DOM节点树（DOM tree），也叫内容树（content tree）；<br>2.构建CSSOM(CSS Object Model)树：加载解析样式生成CSSOM树；<br>3.执行JavaScript：加载并执行JavaScript代码（包括内联代码或外联JavaScript文件）；<br>4.构建渲染树(render tree)：根据DOM树和CSSOM树,生成渲染树(render tree)；</p><p>渲染树：按顺序展示在屏幕上的一系列矩形，这些矩形带有字体，颜色和尺寸等视觉属性。</p><p>5.布局（layout）：根据渲染树将节点树的每一个节点布局在屏幕上的正确位置；</p><p>6.绘制（painting）：遍历渲染树绘制所有节点，为每一个节点适用对应的样式，这一过程是通过UI后端模块完成；</p><h3 id="浏览器加载页面资源的步骤如下（部分参考网络资料）："><a href="#浏览器加载页面资源的步骤如下（部分参考网络资料）：" class="headerlink" title="浏览器加载页面资源的步骤如下（部分参考网络资料）："></a>浏览器加载页面资源的步骤如下（部分参考网络资料）：</h3><p>1.用户输入网址（假设是第一次访问），浏览器向服务器发出请求，服务器返回html文件；<br>2.浏览器开始载入html代码，发现＜head＞标签内有一个＜link＞标签引用外部CSS文件；<br>3.浏览器又发出CSS文件的请求，服务器返回这个CSS文件；<br>4.浏览器继续载入html中＜body＞部分的代码，并且CSS文件已经拿到手了；<br>5.浏览器在代码中发现一个＜img＞标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续加载后面的代码；<br>6.服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码；<br>7.浏览器发现了一个包含一行Javascript代码的＜script＞标签，直接运行该脚本；<br>8.Javascript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个＜div＞ （style.display&#x3D;”none”）。少了一个元素，浏览器不得不重新渲染这部分代码；<br>9.＜&#x2F;html＞表示暂时加载完成；<br>10.此时用户点了一下界面中的“换肤”按钮，Javascript让浏览器换了一下＜link＞标签的CSS路径；<br>11.浏览器向服务器请求了新的CSS文件，重新加载页面。然后执行渲染过程。</p><h3 id="为什么加载js脚本会造成阻塞？-现在还会有这种问题吗？"><a href="#为什么加载js脚本会造成阻塞？-现在还会有这种问题吗？" class="headerlink" title="为什么加载js脚本会造成阻塞？ 现在还会有这种问题吗？"></a>为什么加载js脚本会造成阻塞？ 现在还会有这种问题吗？</h3><p>一个页面的加载顺序是从上到下顺序加载的，并且加载与渲染同时进行。<br>（这里和面试官理解的意思不同，他说以前因为网络问题还是啥，出现ajax后就没有该问题了，可实现异步请求了。）<br>浏览器解析文档时，默认是按照排列顺序向下解析的，当遇到script标签时，和其他标签元素一样（例如一个div），会先解析该元素（脚本），解析完成后再继续向下走完成剩余文档的解析和渲染。也就是说默认情况下，script脚本会阻塞文档的解析渲染。<br>注意，如果我们的script脚本是放在页面底部的内联脚本，那么它对文档的解析渲染，在结果上影响不大。<br>但如果script脚本是外部脚本（通过网址引入的那种），那么这个脚本需要下载和解析执行，这期间会阻塞浏览器对文档的向下解析渲染，直至脚本下载执行完成，才会继续向下解析渲染。如果这个脚本出错了，可能还会导致整个页面永远无法正常渲染呈现。<br>注意，DOM树的生成是受JavaScript代码执行影响的，JavaScript代码会“阻塞”页面UI的渲染。<br>解决：defer acync<br>defer（延迟）：浏览器会立即下载相应的脚本，在下载的过程中页面的处理不会停止，等到文档解析完成后脚本才会执行。若有多个js脚本，就按照引入的顺序执行<br>ascyn（异步）：浏览器会立即下载相应的脚本，在下载的过程中页面的处理不会停止，下载完成后立即执行，执行过程中页面处理会停止。的正常解析渲染。若有多个js脚本，那个先下载完就先执行那个。</p><h3 id="用过vue的哪些指令？"><a href="#用过vue的哪些指令？" class="headerlink" title="用过vue的哪些指令？"></a>用过vue的哪些指令？</h3><p>v-on 绑定事件<br>v-bind：动态的绑定一个或多个属性<br>v-model:数据双向绑定<br>v-once:只渲染元素和组件一次<br>v-if:控制元素的显示与隐藏<br>v-show：控制元素的显示与隐藏、<br>v-for:遍历数组或对象<br>v-text是渲染字符串，会覆盖原先的字符串<br>v-html是渲染为html</p><h3 id="vue里面，实现某个数据的响应式需要用到什么指令？"><a href="#vue里面，实现某个数据的响应式需要用到什么指令？" class="headerlink" title="vue里面，实现某个数据的响应式需要用到什么指令？"></a>vue里面，实现某个数据的响应式需要用到什么指令？</h3><p>Vue.set()</p><h3 id="渲染表单数据需要用到什么指令？"><a href="#渲染表单数据需要用到什么指令？" class="headerlink" title="渲染表单数据需要用到什么指令？"></a>渲染表单数据需要用到什么指令？</h3><p>v-for 和作用域插槽</p><h3 id="那使用v-for渲染下拉框时，如何使其出现selected的初始值呢？"><a href="#那使用v-for渲染下拉框时，如何使其出现selected的初始值呢？" class="headerlink" title="那使用v-for渲染下拉框时，如何使其出现selected的初始值呢？"></a>那使用v-for渲染下拉框时，如何使其出现selected的初始值呢？</h3><p>首先option要加value值，以便v-model可以获取到对应选择的值</p><p>一、当没有绑定v-model，直接给对应的option加selected属性</p><p>二、当给select绑定了v-model的值的时候，要给v-model绑定的data值里写默认值<br><img src="/../img/select.png" alt="这是图片" title="Magic Gardens"></p><h3 id="get和post方法的区别？"><a href="#get和post方法的区别？" class="headerlink" title="get和post方法的区别？"></a>get和post方法的区别？</h3><p>3-10、get和post方法参数上更具体的区别？</p><h3 id="响应参数有什么类型？传输一张图片用到什么类型？（面试官说什么stream流）"><a href="#响应参数有什么类型？传输一张图片用到什么类型？（面试官说什么stream流）" class="headerlink" title="响应参数有什么类型？传输一张图片用到什么类型？（面试官说什么stream流）"></a>响应参数有什么类型？传输一张图片用到什么类型？（面试官说什么stream流）</h3><h3 id="解决跨域的方法"><a href="#解决跨域的方法" class="headerlink" title="解决跨域的方法"></a>解决跨域的方法</h3><p>1、JSONP<br>2、CORS<br>服务器返回响应报文的时候，在响应头中设置一个允许的header<br>res.setHeader(‘Access-Control-Allow-Origin’,’*’)<br>或者express使用中间件 cors<br>下包 npm intall coes<br>&#x2F;&#x2F;配置中间件<br>var cors&#x3D;require(‘cors’)<br>app.use(cors())<br>3、vue.config.js文件中 devServe配置项</p><h3 id="前端本地存储的方式"><a href="#前端本地存储的方式" class="headerlink" title="前端本地存储的方式"></a>前端本地存储的方式</h3><p>cookie<br>localStorage:本地存储(存在硬盘中)<br>sessionStorage:会话存储（存在内存中）<br>4、手写：判断有效括号<br>안그럼:</p><h3 id="Echarts有两种渲染模式，说下区别？"><a href="#Echarts有两种渲染模式，说下区别？" class="headerlink" title="Echarts有两种渲染模式，说下区别？"></a>Echarts有两种渲染模式，说下区别？</h3><p>默认情况下我们下载使用的Echarts渲染模式是canvas,但是它同时支持svg渲染<br>canvas和svg区别？</p><p>1.canvas生成的是图片，位图（也称像素图），不能单独选中某个图形，只能选中整体</p><p>2.svg:放大不失真，能单独选中局部的某个图形，并且可以用css,js来操纵</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">默认<span class="title class_">Echarts</span>用canvas渲染图表，但可以通过renderer来修改渲染模式</span><br><span class="line"></span><br><span class="line"> echarts.<span class="title function_">init</span>(dom,<span class="literal">null</span>,&#123;<span class="attr">renderer</span>:<span class="string">&#x27;更改渲染模式canvas|svg&#x27;</span>&#125;)</span><br><span class="line"> </span><br><span class="line"> 例如： <span class="keyword">let</span> myEchart=echarts.<span class="title function_">init</span>(box,<span class="string">&#x27;customed&#x27;</span>,&#123;<span class="attr">renderer</span>:<span class="string">&#x27;svg&#x27;</span>&#125;)</span><br><span class="line">如果配置渲染模式的话，前面的主题参数如果没有配置不可以省略，必须留位，否则会无法更改渲染模式。</span><br></pre></td></tr></table></figure><h3 id="get和post区别，使用场景？"><a href="#get和post区别，使用场景？" class="headerlink" title="get和post区别，使用场景？"></a>get和post区别，使用场景？</h3><p>如下情况使用GET方法：客户端与服务端的交互像是一个提问(如查询操作、搜索操作、读操作)<br>如下情况使用POST方法：<br>1.交互是一个命令或订单(order)，比提问包含更多信息<br>2.交互改变了服务器端的资源并被用户察觉，例如订阅某项服务<br>3.用户需要对交互产生的结果负责 </p><p>안그럼:<br>讲一下跨域，解决跨域的方式有哪些？<br>4、讲一下浏览器本地存储的方式及区别？</p><h3 id="了解哪些即时通讯的方式？"><a href="#了解哪些即时通讯的方式？" class="headerlink" title="了解哪些即时通讯的方式？"></a>了解哪些即时通讯的方式？</h3><h4 id="1、短轮询"><a href="#1、短轮询" class="headerlink" title="1、短轮询"></a>1、短轮询</h4><p>短轮询的基本思路就是每隔一段时间就向服务器发送http请求，服务器在收到请求之后，不论是否有数据更新，都直接进行响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。<br>这种方式的优点是比较简单，易于理解，实现起来也没有什么技术难点。缺点是显而易见的，这种方式由于需要不断的建立http连接，严重浪费了服务器端和客户端的资源。尤其是在客户端，距离来说，如果有数量级想对比较大的人同时位于基于短轮询的应用中，那么每一个用户的客户端都会疯狂的向服务器端发送http请求，而且不会间断。人数越多，服务器端压力越大，这是很不合理的。</p><p>　　因此短轮询不适用于那些同时在线用户数量比较大，并且很注重性能的Web应用。</p><p>var xhr &#x3D; new XMLHttpRequest();<br> setInterval(function(){<br>  xhr.open(‘GET’,’&#x2F;user’);<br>   xhr.onreadystatechange &#x3D; function(){ };<br>   xhr.send();<br>  },1000)</p><h4 id="2、长轮询（comet）"><a href="#2、长轮询（comet）" class="headerlink" title="2、长轮询（comet）"></a>2、长轮询（comet）</h4><p>ajax实现:</p><p>　　当服务器收到客户端发来的请求后,服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制(服务器端设置)才返回。 。 客户端JavaScript响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。</p><p>　　长轮询和短轮询比起来，明显减少了很多不必要的http请求次数，相比之下节约了资源。长轮询的缺点在于，连接挂起也会导致资源的浪费。</p><p>function ajax(){</p><p>var xhr &#x3D; new XMLHttpRequest();</p><p>xhr.open(‘GET’,’&#x2F;user’);</p><p>xhr.onreadystatechange &#x3D; function(){</p><p>ajax();</p><p>};</p><p>xhr.send();</p><p>}</p><p>轮询与长轮询都是基于HTTP的，两者本身存在着缺陷:轮询需要更快的处理速度；长轮询则更要求处理并发的能力;两者都是“被动型服务器”的体现:服务器不会主动推送信息，而是在客户端发送ajax请求后进行返回的响应。而理想的模型是”在服务器端数据有了变化后，可以主动推送给客户端”,这种”主动型”服务器是解决这类问题的很好的方案。Web Sockets就是这样的方案。</p><h4 id="3、SSE-长连接"><a href="#3、SSE-长连接" class="headerlink" title="3、SSE 长连接"></a>3、SSE 长连接</h4><p>　SSE是HTML5新增的功能，全称为Server-Sent Events。它可以允许服务推送数据到客户端。SSE在本质上就与之前的长轮询、短轮询不同，虽然都是基于http协议的，但是轮询需要客户端先发送请求。而SSE最大的特点就是不需要客户端发送请求，可以实现只要服务器端数据有更新，就可以马上发送到客户端。</p><p>　　SSE的优势很明显，它不需要建立或保持大量的客户端发往服务器端的请求，节约了很多资源，提升应用性能。并且后面会介绍道，SSE的实现非常简单，并且不需要依赖其他插件。</p><h4 id="4、websocket"><a href="#4、websocket" class="headerlink" title="4、websocket"></a>4、websocket</h4><p>　SSE是HTML5新增的功能，全称为Server-Sent Events。它可以允许服务推送数据到客户端。SSE在本质上就与之前的长轮询、短轮询不同，虽然都是基于http协议的，但是轮询需要客户端先发送请求。而SSE最大的特点就是不需要客户端发送请求，可以实现只要服务器端数据有更新，就可以马上发送到客户端。</p><p>　　SSE的优势很明显，它不需要建立或保持大量的客户端发往服务器端的请求，节约了很多资源，提升应用性能。并且后面会介绍道，SSE的实现非常简单，并且不需要依赖其他插件。</p><p>从兼容性角度考虑，短轮询&gt;长轮询&gt;长连接SSE&gt;WebSocket；</p><p>从性能方面考虑，WebSocket&gt;长连接SSE&gt;长轮询&gt;短轮询。</p><p>6、手写：实现一个定时器<br>7、手写：实现input输入框的内容呈现在外面某个区域<br>8、手写：判断回文字符串</p><p>안그럼:</p><h3 id="项目中有用到预处理器嘛？用到了哪些讲一下。"><a href="#项目中有用到预处理器嘛？用到了哪些讲一下。" class="headerlink" title="项目中有用到预处理器嘛？用到了哪些讲一下。"></a>项目中有用到预处理器嘛？用到了哪些讲一下。</h3><p>less、sass<br>3、如何实现水平垂直居中？<br>4、用到了ES6的哪些新特性？<br>5、let，const，var的区别？<br>6、箭头函数与普通函数的区别？<br>7、说一下你对原型链的理解。<br>8、vue2熟悉还是vue3熟悉？<br>9、说一下vue2和vue3生命周期的区别？</p><h3 id="vue中key的作用？"><a href="#vue中key的作用？" class="headerlink" title="vue中key的作用？"></a>vue中key的作用？</h3><p>key是虚拟DOM的标识，当数据发生变化的时候，vue就会根据新数据生成新的虚拟DOM，然后进行新旧虚拟DOM的差异对比。</p><h3 id="说一下浏览器缓存"><a href="#说一下浏览器缓存" class="headerlink" title="说一下浏览器缓存"></a>说一下浏览器缓存</h3><p>浏览器的缓存机制，也就是我们说的http缓存机制<br>浏览器缓存就是指浏览器将用户请求过的静态资源，存储到本地内存和硬盘中，当浏览器在次访问的时候，就可以直接从本地加载，不用子啊此发请求。</p><p>浏览器的缓存机制：<br>1、强缓存：如果缓存资源有效就直接使用缓存资源，不必再像服务器发请求</p><p>2、协商缓存：强缓存失效之后，浏览器会先向服务器发送一个请求，如果资源没有发生修改，则返回一个304的状态，让浏览器使用本地的缓存副本。如果资源发生了修改，就返回修改后的内容。</p><h3 id="说一下浏览器本地存储"><a href="#说一下浏览器本地存储" class="headerlink" title="说一下浏览器本地存储"></a>说一下浏览器本地存储</h3><p>本地缓存：loaclStorage 存储在硬盘中 生命周期是永久的，除非手动清除<br>会话缓存：sessionStorage 存储在内存中 ，当关闭该页面的之后就被清理了</p><h3 id="说一下同源策略"><a href="#说一下同源策略" class="headerlink" title="说一下同源策略"></a>说一下同源策略</h3><p>同源策略就是协议、域名、端口必须要都一致。<br>当协议、域名、端口有一个不同的时候就会产生跨域，<br>14、如何解决跨域问题？</p><h3 id="讲一下防抖和节流，并说一下它们的区别和应用场景"><a href="#讲一下防抖和节流，并说一下它们的区别和应用场景" class="headerlink" title="讲一下防抖和节流，并说一下它们的区别和应用场景"></a>讲一下防抖和节流，并说一下它们的区别和应用场景</h3><h3 id="用过哪些git命令？"><a href="#用过哪些git命令？" class="headerlink" title="用过哪些git命令？"></a>用过哪些git命令？</h3><p>git init 初始化仓库<br>git status 查看仓库状态<br>git add  将文件切换到暂存状态<br>git commit 将暂存的文件存储到仓库中<br>git log 查看修改日志<br>git branch 查看分支<br>git switch 切换分支<br>git merge 合并分支<br>git pull 将代码推到远程仓库<br>git rm 删除文件</p><p>안그럼:<br>2、说一下css的盒模型</p><h3 id="js判断数据类型的方法"><a href="#js判断数据类型的方法" class="headerlink" title="js判断数据类型的方法"></a>js判断数据类型的方法</h3><p>1、typeof<br>2、xxx instanceof xxx<br>3、constructor:constructor是prototype对象上的属性，指向构造函数，<br>4、Object.prototype.toString.call()<br>4、vue2和vue3的区别？<br>5、vue3的proxy相比于vue2的obj.dp，有什么缺点？（兼容性）<br>6、tcp和udp的区别<br>7、项目里面的vuex和localstorge怎么结合使用的，具体说一下<br>8、项目里有用到token吗？怎么处理的？（没用到。。。）<br>9、项目里使用到路由懒加载，说一下<br>10、有了解过react和ts嘛？</p><p>안그럼:</p><h3 id="用过Echarts的哪些图？"><a href="#用过Echarts的哪些图？" class="headerlink" title="用过Echarts的哪些图？"></a>用过Echarts的哪些图？</h3><p>折线、柱状图、饼图</p><h3 id="渲染一个Echarts的折线图时，设置哪些属性？"><a href="#渲染一个Echarts的折线图时，设置哪些属性？" class="headerlink" title="渲染一个Echarts的折线图时，设置哪些属性？"></a>渲染一个Echarts的折线图时，设置哪些属性？</h3><p>x(xAxis)<br>y轴(yAxis)<br>要展示的数据（data）<br>标题（title）<br>series:线的颜色（lineStyle）<br>5、项目的登录功能怎么做的，具体说说</p><h3 id="针对长列表渲染的场景，如何做出优化？"><a href="#针对长列表渲染的场景，如何做出优化？" class="headerlink" title="针对长列表渲染的场景，如何做出优化？"></a>针对长列表渲染的场景，如何做出优化？</h3><p>1、分片渲染（通过浏览器事件环机制，也就是 EventLoop，分割渲染时间）</p><p>2、虚拟列表（只渲染可视区域）<br>让页面只显示我们能看到的东西，看不到的东西不显示，然后监听滚动条的变化，当滚动条变化的时候重新显示可见区域就完事了</p><h3 id="针对大量图片的场景，如何做出优化？"><a href="#针对大量图片的场景，如何做出优化？" class="headerlink" title="针对大量图片的场景，如何做出优化？"></a>针对大量图片的场景，如何做出优化？</h3><p>选择合适的图片格式和压缩大图，可从根源上截图大图加载过慢的问题。<br>使用雪碧图，iconfont，base64，css 代替图片等可减少图片 http 请求，提高页面加载速度。<br>使用 CDN 图片可达到分流的效果，减少服务券压力。<br>图片懒加载，预加载，渐进式图片等可不同程度减少白屏时间，提高产品体验。</p><h3 id="针对app耗电量过多，如何做出优化？"><a href="#针对app耗电量过多，如何做出优化？" class="headerlink" title="针对app耗电量过多，如何做出优化？"></a>针对app耗电量过多，如何做出优化？</h3><p>9、ts中，any、never、unknow、null、undefined、void这几种类型的区别？</p><h3 id="typeof-undefined和typeof-null时会发生什么？"><a href="#typeof-undefined和typeof-null时会发生什么？" class="headerlink" title="typeof undefined和typeof null时会发生什么？"></a>typeof undefined和typeof null时会发生什么？</h3><p>用 typeof 检测 null 返回是object<br>用 typeof 检测 undefined 返回是 undefined</p><h3 id="v-if和v-for的优先级，同时使用时会发生什么？"><a href="#v-if和v-for的优先级，同时使用时会发生什么？" class="headerlink" title="v-if和v-for的优先级，同时使用时会发生什么？"></a>v-if和v-for的优先级，同时使用时会发生什么？</h3><p>v-for的优先级大于v-if,如果两者同时使用的话：每一次遍历都会重复运行v-if</p><h3 id="vue中获取dom节点的方法？获取多个呢？"><a href="#vue中获取dom节点的方法？获取多个呢？" class="headerlink" title="vue中获取dom节点的方法？获取多个呢？"></a>vue中获取dom节点的方法？获取多个呢？</h3><p>事件源（e.target）<br>使用ref（this.$refs）<br>自定义全局指令</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;aa&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">value</span>=<span class="string">&quot;点击&quot;</span> <span class="attr">v-get</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        </span></span><br><span class="line"><span class="language-javascript">        <span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&quot;get&quot;</span>,&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">bind</span>:<span class="keyword">function</span>(<span class="params">el</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">console</span>.<span class="title function_">log</span>(el);</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">el</span>:<span class="string">&#x27;#aa&#x27;</span></span></span><br><span class="line"><span class="language-javascript">        &#125;)</span></span><br><span class="line"><span class="language-javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="git-pull和git-fetch命令的区别？"><a href="#git-pull和git-fetch命令的区别？" class="headerlink" title="git pull和git fetch命令的区别？"></a>git pull和git fetch命令的区别？</h3><p>git fetch #要想推送成功，就必须保证本地库和远程库的版本一致,会从远程仓库下载所有的代码但是他会不将下载的代码和本地的代码进行合并，使用fatch拉取代码后，必须手动合并git merge origin&#x2F;master<br>git pull #拉取代码，并自动合并</p><p>안그럼:<br>3、项目的登录模块是怎么做的？<br>4、面试官说项目有点普通。。。确实</p><h3 id="知道token嘛？说一下它和session的区别"><a href="#知道token嘛？说一下它和session的区别" class="headerlink" title="知道token嘛？说一下它和session的区别"></a>知道token嘛？说一下它和session的区别</h3><p>token是一种验证用户身份的方式，通常是在用户登录后服务器端生成一个token，并将其返回给客户端，客户端在进行后续操作时需要携带此token，服务器端验证token的有效性来确定用户身份。<br>session是保存在服务器端的，用来存储用户信息，并且通过session ID来识别用户。<br>共同点：都是保存了用户身份信息，都有过期时间。</p><p>session翻译为会话，token翻译为令牌。<br>session是空间换时间，token是时间换空间。<br>session和sessionid：服务器会保存一份，可能保存到缓存&#x2F;数据库&#x2F;文件。<br>token：服务器不需要记录任何东西，每次都是一个无状态的请求，每次都是通过解密来验证是否合法。 token 只是一个 key，不存放实际的数据，与这个 token 相关的数据还是存放在服务器上，例如 Session，Redis 等分布式缓存里，用 token 去请求对应的数据。<br>sessionid：一般是随机字符串，要到服务器检索id的有效性。出现请求：服务器重启饿内存中的session没了，数据库服务器挂了。<br>token 和 cookie 本质上没啥区别，只不过 token 只是一个字符串，访问的时候可以放在 url 的参数，header 里等，不像 cookie 那么重量级，而且移动端访问的时候 token 更方便，仅此而已。</p><h3 id="那现在盗取一个用户的token信息，是不是就能进行模拟用户进行操作发起攻击？"><a href="#那现在盗取一个用户的token信息，是不是就能进行模拟用户进行操作发起攻击？" class="headerlink" title="那现在盗取一个用户的token信息，是不是就能进行模拟用户进行操作发起攻击？"></a>那现在盗取一个用户的token信息，是不是就能进行模拟用户进行操作发起攻击？</h3><p>7、实现水平垂直居中的方式<br>8、实现一张图片和视口大小一致，怎么设置？</p><h3 id="说下闭包"><a href="#说下闭包" class="headerlink" title="说下闭包"></a>说下闭包</h3><p>闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。</p><h3 id="闭包的特点"><a href="#闭包的特点" class="headerlink" title="闭包的特点"></a>闭包的特点</h3><p>1.让外部访问函数内部变量变成可能</p><p>2.变量会常驻在内存中</p><p>3.可以避免使用全局变量,防止全局变量污染;</p><h3 id="闭包的好处和坏处"><a href="#闭包的好处和坏处" class="headerlink" title="闭包的好处和坏处"></a>闭包的好处和坏处</h3><p>好处：可以读取其他函数内部的变量，并将其一直保存在内存中。</p><p>坏处：可能会造成内存泄漏或溢出。</p><h3 id="闭包应用场景"><a href="#闭包应用场景" class="headerlink" title="闭包应用场景"></a>闭包应用场景</h3><p>创建私有变量,延长变量的生命周期<br>闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。</p><p>闭包的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。</p><h3 id="使用闭包的注意点"><a href="#使用闭包的注意点" class="headerlink" title="使用闭包的注意点"></a>使用闭包的注意点</h3><p>1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</p><p>2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</p><h3 id="什么是变量提升？"><a href="#什么是变量提升？" class="headerlink" title="什么是变量提升？"></a>什么是变量提升？</h3><p>变量提升即将变量声明提升到它所在作用域的最开始的部分。<br>通过var定义（声明）的变量，在定义语句之前就可以访问到；<br>值：undefined；<br> js中创建函数有两种方式：函数声明式和函数表达式<br> 1、函数声明提升<br>以函数声明来定义函数时，可以在定义函数之前访问到定义的函数。<br>2、函数表达式提升<br> 此种声明方式我们可以理解为一个普通变量的提升<br>函数提升优先级高于变量提升，且不会被同名变量声明时覆盖，但是会被同名变量赋值后覆盖。<br>13、每隔一秒输出一个数应该怎么做？</p><h3 id="说下作用域和作用域链"><a href="#说下作用域和作用域链" class="headerlink" title="说下作用域和作用域链"></a>说下作用域和作用域链</h3><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>就是变量或者是函数能作用的范围。<br>1.全局作用域<br>除了函数中定义的变量之外，都是全局作用域。<br>2.函数作用域<br>创建函数后在花括号中声明的一些语句或变量只在当前函数中起作用。<br>3.块级作用域<br>ES6带来的新特性，在语句块中声明的语句或变量只在当前语句块中起作用。</p><p>函数作用域和块级作用域根本没有直接关系,函数作用域在ES5和ES6作用完全一样,变量不论是使用var声明还是使用了let ,const声明在外部都是不可以访问的。</p><p>块级作用域指的就是使用 if () { }; while ( ) { } …这些语句所形成的语句块 , 并且其中变量必须使用let或const声明(否则就不是块级作用域了),保证了外部不可以访问语句块中的变量。</p><h4 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h4><p>当查找变量的时候，会先从当前作用域的变量对象中查找，如果没有找到，就会从父级作用域(上层环境)的变量对象中查找，一直找到全局作用域的变量对象，也就是全局对象。这样由多个作用域的变量对象构成的链表就叫做作用域链。它由当前环境与上层环境的一系列变量对象组成，保证了当前执行环境对符合访问权限的变量和函数的有序访问。</p><h3 id="说一下ES5中的继承"><a href="#说一下ES5中的继承" class="headerlink" title="说一下ES5中的继承"></a>说一下ES5中的继承</h3><p>1、原型链继承<br>2、借用构造函数继承<br>3、组合继承<br>4、寄生式组合继承</p><h3 id="那再说一下ES6中的继承"><a href="#那再说一下ES6中的继承" class="headerlink" title="那再说一下ES6中的继承"></a>那再说一下ES6中的继承</h3><p>类的继承<br>子 extends 父<br>super()父亲的属性</p><p>17、vue2和vue3的区别？<br>18、proxy的作用，应用场景？</p><h3 id="说一下你了解的排序方式？"><a href="#说一下你了解的排序方式？" class="headerlink" title="说一下你了解的排序方式？"></a>说一下你了解的排序方式？</h3><p>插入<br>冒泡<br>归并<br>选择<br>快速<br>堆排序</p><p>20、逆序数组使用快排的时间复杂度？</p><p>안그럼:</p><h3 id="HTML5的新特性"><a href="#HTML5的新特性" class="headerlink" title="HTML5的新特性"></a>HTML5的新特性</h3><p>1、语义化标签，例如header，footer，section，article等 语义化标签的作用：提升页面的阅读性(结构性增强)，更有利于SEO，对于使用屏幕阅读器的人来说会更友好(有明显的语气差别，例如strong标签内的内容会重读)；<br>2、新增媒体元素，audio、video<br>audio和video标签能够很容易的输出音频或视频流，提供便利的获取文件信息的API<br>3、canvas画布、svg，用于绘画的canvas属性 Canvas API 提供了一个通过JavaScript 和 HTML的canvas元素来绘制图形的方式。它可以用于动画、游戏画面、数据可视化、图片编辑以及实时视频处理等方面。<br>4、新增本地存储方式：sessionStorage、localStorage<br>sessionStorage 用于存储会话级别的数据，会话关闭，数据消失，不可设置过期时间。<br>localStorage 用于存储需要进行持久化存储的数据，只要不主动删除，数据不会消失。<br>5、新的技术：webworker、websocket<br>webworker：用于多线程编程<br>websocket：客户端与服务端双向数据通信协议<br>6、新增的表单控件：calendar、date、time、email、url、search </p><h3 id="说一下用过的伪类和伪元素"><a href="#说一下用过的伪类和伪元素" class="headerlink" title="说一下用过的伪类和伪元素"></a>说一下用过的伪类和伪元素</h3><p>伪类：：hover :visited :link<br>伪元素：::after ::before  :nth-child(1)</p><h3 id="说一下行内元素和块级元素"><a href="#说一下行内元素和块级元素" class="headerlink" title="说一下行内元素和块级元素"></a>说一下行内元素和块级元素</h3><p>行内元素：<br>不会独占一行，相邻的行内元素会排列在同一行里，直到一行排不下才会自动换行，其宽度随元素的内容而变化；<br>高宽无效，对外边距（margin）和内边距（padding）仅设置左右方向有效  上下无效；<br>设置行高有效，等同于给父级元素设置行高；<br>元素的宽度就是它包含的文字或图片的宽度，不可改变；<br>行内元素中不能放块级元素，a 链接里面不能再放链接；<br>块级元素：<br>块级元素各占据一行（ 默认宽度是它本身父容器的100%（和父元素的宽度一致 ），与内容无关），垂直方向排列。<br>每个块级元素都是独自占一行；<br>高度，行高，外边距（margin）以及内边距（padding）都可以控制；<br>元素的宽度如果不设置的话，默认为父元素的宽度（父元素宽度100%；<br>多个块状元素标签写在一起，默认排列方式为从上至下；</p><h3 id="说一下Flex布局"><a href="#说一下Flex布局" class="headerlink" title="说一下Flex布局"></a>说一下Flex布局</h3><p>flex布局就叫做弹性布局</p><h3 id="介绍一下Array-splice方法"><a href="#介绍一下Array-splice方法" class="headerlink" title="介绍一下Array.splice方法"></a>介绍一下Array.splice方法</h3><p>数组的一个方法<br>let arr[1,2,3,4,5,6]<br>arr.splice(0,1,3)<br>里面可以传三个参数，第一个 从索引为0的开始，删除一个数，添加3这个元素</p><h3 id="介绍一下深拷贝"><a href="#介绍一下深拷贝" class="headerlink" title="介绍一下深拷贝"></a>介绍一下深拷贝</h3><p>深拷贝会在堆中重新开辟一个新的空间用来存储拷贝后的内容，两者的值互不影响</p><h3 id="ES6的新特性"><a href="#ES6的新特性" class="headerlink" title="ES6的新特性"></a>ES6的新特性</h3><p>let const<br>symbol<br>扩展运算符<br>模板字符串<br>箭头函数<br>promise<br>Set Map</p><h3 id="介绍一下promise"><a href="#介绍一下promise" class="headerlink" title="介绍一下promise"></a>介绍一下promise</h3><p>Promise是用来解决回调地狱的一种异步操作，有三种状态，padding(进行时)、fullfilled（成功）、rejected（失败）<br>promise中可以传递两个参数，reslove（执行成功的代码）,reject（执行失败的代码）<br>通过.then()获取成功的结果，.catch()捕获失败的结果</p><h3 id="介绍一下async和await，实现机制是什么？（说机制时卡了）"><a href="#介绍一下async和await，实现机制是什么？（说机制时卡了）" class="headerlink" title="介绍一下async和await，实现机制是什么？（说机制时卡了）"></a>介绍一下async和await，实现机制是什么？（说机制时卡了）</h3><p>async&#x2F;await 是ES2017(ES8)提出的基于Promise的解决异步的最终方案。<br>async&#x2F;await：让异步代码，同步实现<br>在一个函数前面加上了async，这个函数返回的就是一个promise对象。因此对async函数可以直接then，返回值就是then方法传入的函数。<br>await:等待，就是等待await后面的函数执行完了，其他的语句才能执行</p><h3 id="介绍一下for…of和for…in的区别？（卡了）"><a href="#介绍一下for…of和for…in的区别？（卡了）" class="headerlink" title="介绍一下for…of和for…in的区别？（卡了）"></a>介绍一下for…of和for…in的区别？（卡了）</h3><p>for…in和for…of都是用于遍历数组或对象的循环语句，但是它们的作用不同。</p><p>for…in循环用于遍历对象的属性，返回的是属性名。而for…of循环用于遍历可迭代对象（如数组、字符串、Set、Map等），返回的是元素值。</p><p>举个例子，对于一个数组arr，使用for…in循环会返回数组的索引，而使用for…of循环会返回数组的元素值。</p><p>for(let i in arr){<br>console.log(i); &#x2F;&#x2F;输出数组的索引<br>}</p><p>for(let i of arr){<br>console.log(i); &#x2F;&#x2F;输出数组的元素值<br>}</p><p>因此，for…in循环适用于遍历对象的属性，而for…of循环适用于遍历数组等可迭代对象的元素</p><h3 id="能用for…of去遍历一个对象吗？"><a href="#能用for…of去遍历一个对象吗？" class="headerlink" title="能用for…of去遍历一个对象吗？"></a>能用for…of去遍历一个对象吗？</h3><p>不可以</p><h3 id="js合并数组的方式有哪些？"><a href="#js合并数组的方式有哪些？" class="headerlink" title="js合并数组的方式有哪些？"></a>js合并数组的方式有哪些？</h3><p>concat()方法<br>扩展运算符</p><h3 id="如何识别当前的设备？"><a href="#如何识别当前的设备？" class="headerlink" title="如何识别当前的设备？"></a>如何识别当前的设备？</h3><p>16、现在主要是用vue2还是vue3？</p><h3 id="computed和watch的区别？"><a href="#computed和watch的区别？" class="headerlink" title="computed和watch的区别？"></a>computed和watch的区别？</h3><p>1、功能：computed是计算属性；watch是监听一个值的变化执行对应的回调<br>2、是否调用缓存：computed函数所依赖的属性不变的时候会调用缓存；watch每次监听的值发生变化时候都会调用回调<br>3、是否调用return：computed必须有；watch可以没有<br>4、使用场景：computed当一个属性受多个属性影响的时候；例如购物车商品结算；watch当一条数据影响多条数据的时候，例如搜索框<br>5、是否支持异步：computed函数不能有异步；watch可以</p><h3 id="为什么watch支持异步操作？（不会，只答了可能与promise相关）"><a href="#为什么watch支持异步操作？（不会，只答了可能与promise相关）" class="headerlink" title="为什么watch支持异步操作？（不会，只答了可能与promise相关）"></a>为什么watch支持异步操作？（不会，只答了可能与promise相关）</h3><p>19、兄弟组件通信的方式？<br>全局事件总线<br>pubsub<br>vuex<br>20、说一下vue的路由模式<br>hash模式<br>历史模式</p><h3 id="说一下http1-1，2-0，3-0的区别"><a href="#说一下http1-1，2-0，3-0的区别" class="headerlink" title="说一下http1.1，2.0，3.0的区别"></a>说一下http1.1，2.0，3.0的区别</h3><p>HTTP 1.1<br>长连接，流水线，使用connection:keep-alive使用长连接<br>请求管道化<br>增加缓存处理（新的字段如cache-control）<br>增加Host字段，支持断点传输等<br>由于长连接会给服务器造成压力<br>HTTP 2.0<br>二进制分帧<br>头部压缩，双方各自维护一个header的索引表，使得不需要直接发送值，通过发送key缩减头部大小<br>多路复用（或连接共享），使用多个stream，每个stream又分帧传输，使得一个tcp连接能够处理多个http请求<br>服务器推送（Sever push）<br>HTTP 3.0<br>基于google的QUIC协议，而quic协议是使用udp实现的<br>减少了tcp三次握手时间，以及tls握手时间<br>解决了http 2.0中前一个stream丢包导致后一个stream被阻塞的问题<br>优化了重传策略，重传包和原包的编号不同，降低后续重传计算的消耗<br>连接迁移，不再用tcp四元组确定一个连接，而是用一个64位随机数来确定这个连接<br>更合适的流量控制</p><h3 id="说一下websocket"><a href="#说一下websocket" class="headerlink" title="说一下websocket"></a>说一下websocket</h3><p>websocket是一种通信协议，它实现了浏览器与服务器全双工通信，能更好的节省服务器资源和带宽并达到实时通讯的目的<br>Websocket是一个持久化的协议<br>23、对Linux有了解嘛？（没咋了解，只会一些简单的命令）<br>24、查看80端口被谁占用了应该用什么命令？（不会）<br>25、有了解过Docker嘛？（没有，只知道它是一个用于部署的容器）<br>26、项目是怎么部署的？（本菜鸡用的宝塔。。。）<br>27、有对nginx做过什么配置吗？（没有）</p><h3 id="有用过git嘛？说一下常用的git命令？"><a href="#有用过git嘛？说一下常用的git命令？" class="headerlink" title="有用过git嘛？说一下常用的git命令？"></a>有用过git嘛？说一下常用的git命令？</h3><p>git init 初始化仓库<br>git add <filename>  #将文件切换到暂存状态<br>git add * #将所有已修改的文件暂存<br>git commit -m “xxxx” #将暂存的文件存储到仓库中 xxxx里面一般写提交的代码实现了什么功能，修改了什么bug<br>git commit -a -m “xxxx” #提交所有已修改的文件（未跟踪的文件不会提交）<br>git restore <fliename>   #恢复文件<br>git restore –staged <fliename>   #把文件从暂存的状态取消<br>git rm <filename> #删除文件<br>git rm <filename> -f  #表示强制删除<br>git mv from to #移动文件  重命名文件<br>git switch <branch name>  切换分支<br>git merge &lt;修改bug的分支&gt;  合并分支<br>git branch -d <branch name> 删除分支<br>git status 查看当前仓库的状态<br>git log  查看修改日志<br>git branch  查看分支<br>git branch <branch name> 创建新的分支<br>git branch -d <branch name> 删除分支<br>git switch <branch name> 切换分支<br>git switch -c <branch name> 创建并切换分支<br>git remote #显示当前关联的所有远程库<br>git remote &lt;远程库名&gt; <url> #关联远程仓库<br>git remote remove &lt;远程库名&gt;  #删除远程库<br>git push -u &lt;远程库名&gt; &lt;分支名&gt; #向远程仓库推送代码，并和当前分支关联<br>git push &lt;远程库&gt; &lt;本地分支&gt;:&lt;远程分支&gt; #把办呢滴分支推送到指定的远程分支上<br>git clone <url> #从远程仓库上下载代码</p><p>如果本地库的版本低于远程库的版本，push是默认推不上去的，要想推送成功，就必须保证本地库和远程库的版本一致<br>git fetch #要想推送成功，就必须保证本地库和远程库的版本一致,会从远程仓库下载所有的代码但是他会不将下载的代码和本地的代码进行合并，使用fatch拉取代码后，必须手动合并git merge origin&#x2F;master<br>git pull #拉取代码，并自动合并</p><h3 id="git-pull和git-fetch的区别是什么？"><a href="#git-pull和git-fetch的区别是什么？" class="headerlink" title="git pull和git fetch的区别是什么？"></a>git pull和git fetch的区别是什么？</h3><p>git fetch从远程仓库下载代码，不会与本地迪马进行合并，拉取后，需要手动合并<br>git pull拉取代码，自动合并</p><p>안그럼:</p><h3 id="说一下ES5中的继承-1"><a href="#说一下ES5中的继承-1" class="headerlink" title="说一下ES5中的继承"></a>说一下ES5中的继承</h3><p>1、原型链继承<br>2、构造函数继承<br>3、组合式继承<br>4、寄生组合继承<br>5、class类继承</p><h3 id="ES6的继承中super是用来干嘛的？"><a href="#ES6的继承中super是用来干嘛的？" class="headerlink" title="ES6的继承中super是用来干嘛的？"></a>ES6的继承中super是用来干嘛的？</h3><p>用来继承父元素的属性的</p><h3 id="CommonJS模块和ES6模块的区别？"><a href="#CommonJS模块和ES6模块的区别？" class="headerlink" title="CommonJS模块和ES6模块的区别？"></a>CommonJS模块和ES6模块的区别？</h3><p>1、使用环境：<br>CommonJS模块的require语法是同步的，逃至他只能运行在服务端，ES6无论是服务端还是浏览器端都可以运行，不过运行在服务端要遵循一些特殊的规则才能使用<br>2、输出方式不同：<br>CommonJS输出的是一个值的拷贝<br>ES6输出的是一个值的引用<br>3、运行时加载和编译时加载<br>commonJS是运行时加载<br>ES6是编译时加载<br>4、互相引用<br>ES6模块中可以引用CommonJS模块<br>但是CommonJS模块中不能引用ES6模块</p><h3 id="引入一个js文件时，我们在script标签上设置type-x3D-module，是为了什么呢？"><a href="#引入一个js文件时，我们在script标签上设置type-x3D-module，是为了什么呢？" class="headerlink" title="引入一个js文件时，我们在script标签上设置type&#x3D;module，是为了什么呢？"></a>引入一个js文件时，我们在script标签上设置type&#x3D;module，是为了什么呢？</h3><p>模块化引入js文件</p><h3 id="说一下原型和原型链（面试官纠正了一下）"><a href="#说一下原型和原型链（面试官纠正了一下）" class="headerlink" title="说一下原型和原型链（面试官纠正了一下）"></a>说一下原型和原型链（面试官纠正了一下）</h3><p>原型：每一个实例的身上都有一个__proto__属性，然后每一个构造函数身上都有一个prototype属性<br>JS声明构造函数(用来实例化对象的函数)时，会在内存中创建一个对应的对象，这个对象就是原函数的原型。构造函数默认有一个prototype属性，prototype的值指向函数的原型。同时原型中也有一个constructor属性，constructor的值指向函数对象。<br>通过构造函数实例化出来的对象，并不具有prototype属性，其默认有一个__proto__属性，__proto__的值指向构造函数的原型。在原型对象上添加或修改的属性，在所有实例化出的对象上都可共享。</p><p>原型链：当在实例化的对象中访问一个属性时，首先会在该对象内部(自身属性)寻找，如找不到，则会向其__proto__指向的原型中寻找，如仍找不到，则继续向原型中__proto__指向的上级原型中寻找，直至找到或Object.prototype.__proto__为止（值为null），这种链状过程即为原型链</p><h3 id="new一个function，则new出来的对象的constructor是什么？"><a href="#new一个function，则new出来的对象的constructor是什么？" class="headerlink" title="new一个function，则new出来的对象的constructor是什么？"></a>new一个function，则new出来的对象的constructor是什么？</h3><p>当使用new命令时，它后面的函数依次执行下面的4个步骤：</p><p>1、创建一个空对象，作为将要返回的对象实例。<br>2、将这个空对象的原型，指向构造函数的prototype属性。<br>3、将这个空对象赋值给函数内部的this关键字。<br>4、开始执行构造函数内部的代码。</p><h3 id="ES6新增的数据类型（理解有差错，我理解的map和set不是数据类型的）"><a href="#ES6新增的数据类型（理解有差错，我理解的map和set不是数据类型的）" class="headerlink" title="ES6新增的数据类型（理解有差错，我理解的map和set不是数据类型的）"></a>ES6新增的数据类型（理解有差错，我理解的map和set不是数据类型的）</h3><p>symbol、Set、Map、 Bigint<br>14、vue2和vue3的区别？<br>15、vue2的obj.dp为什么不能去检测数组这种类型的变化？</p><h3 id="for…of和for…in的区别？想通过for-of遍历一个object怎么做？遍历原型链用哪个？"><a href="#for…of和for…in的区别？想通过for-of遍历一个object怎么做？遍历原型链用哪个？" class="headerlink" title="for…of和for…in的区别？想通过for of遍历一个object怎么做？遍历原型链用哪个？"></a>for…of和for…in的区别？想通过for of遍历一个object怎么做？遍历原型链用哪个？</h3><p>for of遍历的是一个可迭代对象，得到的是元素值（不可以遍历对象）<br>for in 遍历的是属性名<br>遍历原型链可以用for in<br>如果想通过for of遍历对象，可以向将对象JSON.toString()变成字符串，然后遍历</p><h3 id="for，foreach，map的区别"><a href="#for，foreach，map的区别" class="headerlink" title="for，foreach，map的区别"></a>for，foreach，map的区别</h3><p> map方法：</p><p>(1)map方法返回一个新的数组,数组中的元素为原始数组调用函数处理后的值</p><p>(2)map方法不会对空的数组进行检测,map方法不会改变原始数组<br>forEach方法：  </p><p>1.forEach方法用来调用数组的每一个元素,将元素传给回调的函数</p><p>2.forEach对于空数组是不会调用回调函数的</p><p>中止循环。for 通过 break 关键字来中止循环，forEach 和 map 不可以。<br>跳过此次循环。for 通过 continue 来跳过，forEach 通过 return 跳过，map 不能跳过。<br>返回值。map 返回一个数组，在 map 的回调函数中，不使用 return 返回值的话，会返回 undeifned。for 和 forEach 没有返回值。<br>改变原数组。map 不改变原数组，for 和 forEach 可以改变原数组。<br>代码量。for 的代码量比 forEach 和 map 要多。</p><h3 id="generator的应用场景（异步代码同步化）"><a href="#generator的应用场景（异步代码同步化）" class="headerlink" title="generator的应用场景（异步代码同步化）"></a>generator的应用场景（异步代码同步化）</h3><p>Generator 函数是 ES6 提供的一种异步编程解决方案</p><h3 id="computed和watch的区别？-1"><a href="#computed和watch的区别？-1" class="headerlink" title="computed和watch的区别？"></a>computed和watch的区别？</h3><h3 id="computed为什么支持缓存，watch为什么支持异步？"><a href="#computed为什么支持缓存，watch为什么支持异步？" class="headerlink" title="computed为什么支持缓存，watch为什么支持异步？"></a>computed为什么支持缓存，watch为什么支持异步？</h3><p> computed的getter在初次读取时执行后，会将结果进行缓存，如果在其他地方再次访问时，当依赖的数据没有发生改变时，会直接拿缓存;<br> watch是监视属性，只有当数据发生变化的时候才会执行相应的回调<br>21、webpack的基础配置有哪些？<br>22、有了解webpack的chunk嘛？</p><h3 id="打包出来的包可能会很大，造成卡顿，比如首屏加载优化怎么处理？（按需加载了解吗？）"><a href="#打包出来的包可能会很大，造成卡顿，比如首屏加载优化怎么处理？（按需加载了解吗？）" class="headerlink" title="打包出来的包可能会很大，造成卡顿，比如首屏加载优化怎么处理？（按需加载了解吗？）"></a>打包出来的包可能会很大，造成卡顿，比如首屏加载优化怎么处理？（按需加载了解吗？）</h3><p>1.减小入口文件体积，</p><p>2.静态资源本地缓存，</p><p>3.UI框架按需引入，</p><p>4.图片资源的压缩，以及使用图片懒加载，路由懒加载</p><p>5.依赖模块采用第三方cdn资源 </p><p>6.开启GZip打包，webpack开启gzip压缩文件传输模式</p><p>7.开启SSR<br>禁止生成map文件<br>去掉代码中的console和debugger<br>预渲染配置：使用插件：prerender-spa-plugin </p><p>8.去除loading</p><h3 id="回流和重绘的区别？什么时候造成回流重绘？怎么解决？"><a href="#回流和重绘的区别？什么时候造成回流重绘？怎么解决？" class="headerlink" title="回流和重绘的区别？什么时候造成回流重绘？怎么解决？"></a>回流和重绘的区别？什么时候造成回流重绘？怎么解决？</h3><h4 id="回流"><a href="#回流" class="headerlink" title="回流"></a>回流</h4><p>浏览器会把获取到的HTML代码解析成一个DOM树，html中的每一个元素都是DOM树的一个节点，根节点也就是我们说的document对象。在渲染树中的一部分（或者全部）因为元素的规模尺寸、布局 、显隐等改变而需要重新构建，这就称为回流。每次页面至少会发生一次回流，就是在页面第一次渲染的时候。<br>何时发生回流?</p><p>添加或者删除可见的DOM元素<br>元素的位置发生变化<br>元素的尺寸发生变化（包括外边距、内边距、边框大小、高度和宽度等）<br>内容发生变化，文本或者图片被另一个不同尺寸的图片所代替<br>页面开始渲染的时候<br>浏览器的窗口尺寸变化（回流是根据视口的大小来计算元素的位置和大小的）</p><h4 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h4><pre><code>    在渲染树中的一些元素需要更新属性，而这些属性只是影响元素的外观、风格，不影响布局，就称为重绘。</code></pre><p>什么时候发生重绘？<br>1、背景色改变<br>2、样式发生改变的时候</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><pre><code>    回流必定会引起重绘，重绘一定不会引起回流    回流会导致页面重排，影响性能</code></pre><h3 id="为什么h5和css写的动画会比用js写的流畅一些？"><a href="#为什么h5和css写的动画会比用js写的流畅一些？" class="headerlink" title="为什么h5和css写的动画会比用js写的流畅一些？"></a>为什么h5和css写的动画会比用js写的流畅一些？</h3><p>1、css动画是补帧动画，js是逐帧动画<br>2、采用 JS 去实现的动画，无论多简单的动画，都需要去控制整个过程，当然你可能会说可以采用一些库来解决这些问题，但是这些库的实际运行可能要比原生实现的效率要低的多<br>3、性能的高效，在我们前面讲到了回流和重绘，如果我们要操作一个元素向右移动，我们可能需要控制 dom.style.left 属性，每次来改变元素的位置，而结合我们所说的，几何属性的改变必然会引起回流，回流必然引起重绘，可想而知如果我们采用 JS 来实现动画，这个代价有多大，这会造成浏览器在不断的计算页面，从而导致浏览器内存堆积。同时由于 JavaScript 运行在浏览器的主线程中，主线程中还有其他的重要任务在运行，因而可能会受到干扰导致线程阻塞，从而丢帧</p><p>而 CSS 的动画是运行在合成线程中的，不会阻塞主线程，并且在合成线程中完成的动作不会触发回流和重绘</p><p>当然还有一个重要的点：JS 动画运行在 CPU，而 CSS 动画运行在 GPU</p><p>总的来说， CSS动画的渲染成本小，并且它的执行效率高于 JavaScript 动画</p><h3 id="有了解过webworker嘛？"><a href="#有了解过webworker嘛？" class="headerlink" title="有了解过webworker嘛？"></a>有了解过webworker嘛？</h3><h3 id="apply，call，bind三者的区别"><a href="#apply，call，bind三者的区别" class="headerlink" title="apply，call，bind三者的区别"></a>apply，call，bind三者的区别</h3><p>apply方法<br>apply接受两个参数，第一个参数是this的指向，第二个参数是函数接受的参数，以数组的形式传入，且当第一个参数为null、undefined的时候，默认指向window(在浏览器中)，使用apply方法改变this指向后原函数会立即执行，且此方法只是临时改变thi指向一次。<br>call方法<br>call方法的第一个参数也是this的指向，后面传入的是一个参数列表（注意和apply传参的区别）。当一个参数为null或undefined的时候，表示指向window（在浏览器中），和apply一样，call也只是临时改变一次this指向，并立即执行。<br>bind方法<br>bind方法和call很相似，第一参数也是this的指向，后面传入的也是一个参数列表(但是这个参数列表可以分多次传入，call则必须一次性传入所有参数)，但是它改变this指向后不会立即执行，而是返回一个永久改变this指向的函数。<br>三者都可以改变函数的this对象指向。<br>三者第一个参数都是this要指向的对象，如果如果没有这个参数或参数为undefined或null，则默认指向全局window。<br>三者都可以传参，但是apply是数组，而call是参数列表，且apply和call是一次性传入参数，而bind可以分为多次传入。<br>bind 是返回绑定this之后的函数，便于稍后调用；apply 、call 则是立即执行 </p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>vue冲冲冲！</title>
      <link href="/2022/12/19/vue/"/>
      <url>/2022/12/19/vue/</url>
      
        <content type="html"><![CDATA[<h1 id="vue笔记"><a href="#vue笔记" class="headerlink" title="vue笔记"></a>vue笔记</h1><h2 id="脚手架文件结构"><a href="#脚手架文件结构" class="headerlink" title="脚手架文件结构"></a>脚手架文件结构</h2><pre><code>├── node_modules ├── public│   ├── favicon.ico: 页签图标│   └── index.html: 主页面├── src│   ├── assets: 存放静态资源│   │   └── logo.png│   │── component: 存放组件│   │   └── HelloWorld.vue│   │── App.vue: 汇总所有组件│   │── main.js: 入口文件├── .gitignore: git版本管制忽略的配置├── babel.config.js: babel的配置文件├── package.json: 应用包配置文件 ├── README.md: 应用描述文件├── package-lock.json：包版本控制文件</code></pre><h2 id="关于不同版本的Vue"><a href="#关于不同版本的Vue" class="headerlink" title="关于不同版本的Vue"></a>关于不同版本的Vue</h2><blockquote><p>1、vue.js和vue.runtime.xxx.js的区别：<br>     （1）、vue.js时完整版的Vue，包含：核心模块和模板解析器<br>     （2）、vue.runtime.xxx.js时运行版Vue，只包含：核心功能，没有模板解析器</p><p>2、因为vue.runtime.xxx.js没有模板解析器，所以不能使用template配置项，需要使用render函数接收到的createElement函数去指定具体内容</p></blockquote><h2 id="vue-config-js配置文件"><a href="#vue-config-js配置文件" class="headerlink" title="vue.config.js配置文件"></a>vue.config.js配置文件</h2><blockquote><p>使用vue inspect &gt; output.js可以查看Vue脚手架的默认配置<br>使用vue.config.js可以对脚手架进行个性化定制，详情见：<a href="https://cli.vuejs.org/zh/config/">https://cli.vuejs.org/zh/config/</a>    </p></blockquote><h2 id="ref属性"><a href="#ref属性" class="headerlink" title="ref属性"></a>ref属性</h2><blockquote><p>1、被用来给元素或子组件注册引用信息<br>2、应用在html标签上获取的是真实的DOM元素，应用在子组件标签上获取的是组件实例对象 vc<br>3、使用方式</p><blockquote><ul><li>打标识:<br> <code>&lt;h1 v-text=&quot;msg&quot; ref=&quot;title&quot;&gt;xxx&lt;/h1&gt;</code><br>   <code>&lt;School ref=&quot;sch&quot; /&gt;</code></li><li>获取：<blockquote><ul><li>console.log(this.$refs.title);  真实的DOM元素 </li><li>console.log(this.$refs.sch);  School组件的实例对象 vc</li></ul></blockquote></li></ul></blockquote></blockquote><h2 id="配置项props"><a href="#配置项props" class="headerlink" title="配置项props"></a>配置项props</h2><pre><code>功能:让组件接受外部传过来的数据 （1）、传递数据：     &lt;Student uname=&quot;羊仔&quot; sex=&quot;男&quot; :age=&quot;18&quot;&gt;&lt;/Student&gt; （2）、接收数据    第一种方式（只接收）：      props: [&quot;uname&quot;, &quot;sex&quot;, &quot;age&quot;],     第二种方式（限制类型）：          props: &#123;           uname: String,           sex: String,           age: Number,           &#125;,      第三种方式（限制类型、限制必要性、指定默认值）            props: &#123;              uname: &#123;                type: String, //uname的类型是字符串                required: true, //uname是必要的              &#125;,              sex: &#123;                type: String, //sex的类型是字符串                required: true, //sex是必要的              &#125;,              age: &#123;                type: Number, //age的类型是数字型                required: true, //age是必要的                default: 20, //默认值              &#125;,            &#125;,   </code></pre><blockquote><ul><li>备注：props是只读的，Vue底层会监测你对props的修改，如果进行了<br>修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。</li></ul></blockquote><h2 id="mixin-混合-x2F-混入"><a href="#mixin-混合-x2F-混入" class="headerlink" title="mixin(混合&#x2F;混入)"></a>mixin(混合&#x2F;混入)</h2><pre><code>功能:可以把多个组件共用的配置提取成一个混入对象# 本地图片</code></pre>  <img src="./src/assets/mixin.png" alt="示例图片" style="zoom:50%;" /><pre><code>使用方式:  第一步：定义混合 （在main.ja的同级目录下，创建一个mixin.js文件）</code></pre> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">//将混合暴露出模块</span></span><br><span class="line">      <span class="keyword">export</span> <span class="keyword">const</span> mixin = &#123;</span><br><span class="line">          <span class="attr">methods</span>: &#123;</span><br><span class="line">              <span class="title function_">showName</span>(<span class="params"></span>) &#123;</span><br><span class="line">                  <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">uname</span>);</span><br><span class="line">              &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">      &#125;</span><br><span class="line"><span class="string">``</span><span class="string">`     </span></span><br><span class="line"><span class="string">      第二步：使用混合：</span></span><br><span class="line"><span class="string">       （1）、全局引入（写在main.js中）</span></span><br><span class="line"><span class="string">            import &#123; mixin &#125; from &#x27;./mixin&#x27;</span></span><br><span class="line"><span class="string">            Vue.mixin(mixin)</span></span><br><span class="line"><span class="string">       （2）、局部引入</span></span><br><span class="line"><span class="string">           import &#123; mixin &#125; from &quot;../mixin&quot;;</span></span><br><span class="line"><span class="string">           mixins: [mixin],</span></span><br><span class="line"><span class="string"> + 注意：</span></span><br><span class="line"><span class="string"> &lt;table&gt;&lt;tr&gt;&lt;td bgcolor=MistyRose&gt;</span></span><br><span class="line"><span class="string">全局引入 &lt;font color=red&gt;写在main.js中&lt;/font&gt;</span></span><br><span class="line"><span class="string">局部引入 &lt;font color=red&gt;写在要引入的组件中&lt;/font&gt;</span></span><br><span class="line"><span class="string">&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 插件</span></span><br><span class="line"><span class="string"> &gt;     功能：用于增强Vue</span></span><br><span class="line"><span class="string">&gt;     本质：包含install方法的一个对象，install的第一个参数是Vue，第二个参数是插件使用者传递的数据。</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line">    定义插件：</span><br><span class="line">     install = <span class="keyword">function</span>(<span class="params">Vue,options</span>)&#123;</span><br><span class="line">        <span class="comment">//全局过滤器必须在new Vue实例之前就写好</span></span><br><span class="line">        <span class="title class_">Vue</span>.<span class="title function_">filter</span>(<span class="string">&quot;mySlice&quot;</span>, <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value.<span class="title function_">slice</span>(<span class="number">0</span>, <span class="number">4</span>) <span class="comment">//从索引号开始，截取4位</span></span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="comment">//全局指令 </span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">directive</span>(<span class="string">&#x27;fBind&#x27;</span>, &#123;</span><br><span class="line">        <span class="comment">// 指令与元素成功绑定的时候会被调用</span></span><br><span class="line">        <span class="title function_">bind</span>(<span class="params">element, binding</span>) &#123;</span><br><span class="line">            element.<span class="property">value</span> = binding.<span class="property">value</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;bind&#x27;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//指令所在元素被插入页面的时候调用</span></span><br><span class="line">        <span class="title function_">inserted</span>(<span class="params">element, binding</span>) &#123;</span><br><span class="line">            element.<span class="title function_">focus</span>()</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;inserted&#x27;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 当指令所在的模板被重新解析时就会被调用</span></span><br><span class="line">        <span class="title function_">update</span>(<span class="params">element, binding</span>) &#123;</span><br><span class="line">            element.<span class="property">value</span> = binding.<span class="property">value</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;update&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//全局混入</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="title function_">mixin</span>(&#123;</span><br><span class="line">       <span class="title function_">data</span>(<span class="params"></span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> &#123;</span><br><span class="line">               <span class="attr">x</span>: <span class="number">1</span>,</span><br><span class="line">               <span class="attr">y</span>: <span class="number">2</span>,</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   </span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">//给Vue原型上添加一个方法（vm和vc上面都可以用了）  Vue原型上面的属性和方法 vm 和 vc 都可以用 </span></span><br><span class="line">      <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hello</span> = <span class="function">() =&gt;</span> &#123; <span class="title function_">alert</span>(<span class="string">&quot;bkpp是真的！！！&quot;</span>) &#125;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><h2 id="scoped-样式"><a href="#scoped-样式" class="headerlink" title="scoped 样式"></a>scoped 样式</h2><blockquote><p>   功能：让样式在局部生效<br>   写法：<code>&lt;style scoped&gt;</code></p></blockquote><h2 id="总结TodoList案例"><a href="#总结TodoList案例" class="headerlink" title="总结TodoList案例"></a>总结TodoList案例</h2><p>  1、 组件化编码流程:</p><pre><code> (1)、 拆分静态组件:组件要按照功能点拆分.命名不要与html元素冲突 (2)、实现动态组件:考虑好数据的存放位置,数据是一个组件在用,还是一些组件     在用    1)、 一个组件在用:放在组件自身    2)、 一些组件在用:放在他们共同的父组件上面(状态提升) (3)、 实现交互:从绑定事件开始</code></pre><p>  2 props适用于</p><pre><code>   (1)、 父组件===&gt;子组件 通信 (属性)   (2)、 子组件 ===&gt; 父组件  通信 (方法, 要求父组件事先准备一个函数,传给子组件,子组件在适当的时机调用)</code></pre><p>  3、 使用v-model时要切记,v-model绑定的值不能时props传过来的值,因为props时不可修改的<br>  4、 props传过来的若是对象类型的值,修改对象中的属性时vue监测不到,不会报错,但是不推荐这样做  </p><h2 id="webStorage"><a href="#webStorage" class="headerlink" title="webStorage"></a>webStorage</h2><p>  1、存储内容的大小一般支持5MB左右（不同浏览器可能还不一样）<br>  2、浏览器能通过Window.sessionStorage和Window.localStorage属性来实现本地存储机制<br>  3、相关API:</p><pre><code>(1)、xxxStorage.setItem(&#39;key&#39;,&#39;value&#39;)      该方法接受一个键和值作为参数，会把键值对添加加到存储中，如果键名存在，则更新对应的值（2）、xxxStorage.getItem(&#39;person&#39;)           该方法接受一个键名作为参数，返回键名对应的值（3）、xxxxStorage.removeItem(&#39;key&#39;)         该方法接受一个键名作为参数，并把该键名从存储中删除（4）、xxxxStorage.clear()        该方法会清除存储中的所有数据</code></pre><p>  4、备注：</p><pre><code> 1、sessionStorage存储的内容会随浏览器窗口的关闭而消失 2、localStroage存储的内容，需要手动清除才会消失 3、xxxStorage.getItem(&#39;key&#39;)如果key对应的value找不到，那么getItem返回的就是null 4、JSON.parse(null) 返回的结果仍为null</code></pre><h2 id="组建的自定义事件"><a href="#组建的自定义事件" class="headerlink" title="组建的自定义事件"></a>组建的自定义事件</h2><p>   1、一种组件间通信的方式：子组件 &#x3D;&#x3D;&#x3D;&gt; 父组件<br>   2、使用场景：子组件想给父组件传数据，那么就要在父组件中给子组件绑定自定义事件（事件的回调在父组件中）<br>  3、绑定自定义事件<br>     （1）、第一种方式 ： 在父组件中<br>   <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Student</span> <span class="attr">v-on:jing</span>=<span class="string">&quot;getStudentName&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">Student</span>&gt;</span>  或  <span class="tag">&lt;<span class="name">Student</span> @<span class="attr">jing</span>=<span class="string">&quot;getStudentName&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">Student</span>&gt;</span></span><br></pre></td></tr></table></figure><br>  （2）、第二种方式： 在父组件中<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> &lt;<span class="title class_">Student</span> ref=<span class="string">&quot;student&quot;</span> &gt;&lt;/<span class="title class_">Student</span>&gt;</span><br><span class="line"> ....</span><br><span class="line"> <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">$refs</span>.<span class="property">student</span>.$on(<span class="string">&quot;jing&quot;</span>, <span class="variable language_">this</span>.<span class="property">getStudentName</span>); <span class="comment">//绑定自定义事件</span></span><br><span class="line"> &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><br>  （3）、若想让自定义事件只触发一次，可以使用once修饰符 或  $once()方法</p><p>   4、触发自定义事件：</p><pre><code>this.$emit(&quot;jing&quot;, this.uname, 1, 2, 3, 4);</code></pre><p>  5、解绑自定义事件：</p><pre><code> this.$off(&quot;jing&quot;); //解绑一个自定义事件 this.$off([&quot;jing&quot;, &quot;demo&quot;]); //解绑多个自定义事件 this.$off(); //解绑所有的自定义事件</code></pre><p>  6、组件上也可以绑定原生DOM事件，不过需要native修饰符<br>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Student</span> <span class="attr">ref</span>=<span class="string">&quot;student&quot;</span> @<span class="attr">click.native</span>=<span class="string">&quot;show&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Student</span>&gt;</span></span><br></pre></td></tr></table></figure><br>   7、注意：</p><pre><code>通过 this.$refs.student.$on(&quot;jing&quot;,回调); 绑定的自定义事件，回调要么配置在methods中，要么使用箭头函数</code></pre><h2 id="全局事件总线"><a href="#全局事件总线" class="headerlink" title="全局事件总线"></a>全局事件总线</h2><p>  1、一种组件间的通信方式：适用于任意组件间通信<br>  2、安装全局事件总线</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">   <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">   <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">   <span class="title function_">beforeCreate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//生命周期里面的this是vue实例</span></span><br><span class="line">    <span class="title class_">Vue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">$bus</span> = <span class="variable language_">this</span> <span class="comment">//安装全局事件总线</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>   3、使用事件总线<br>    （1）、接收数据：A组件先后接受数据，则在A组件中给$bus绑定自定义事件， <strong style="color:#DD5145">事件的回调留在A中</strong><br> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">   <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">$bus</span>.$on(<span class="string">&quot;hello&quot;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="comment">//绑定hello这个自定义事件</span></span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我是School组件，我收到了数据&quot;</span>, data);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;,</span><br><span class="line"><span class="title function_">methods</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="title function_">demo</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    ....</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>    (2)、提供数据  </p><pre><code>   this.$bus.$emit(&quot;hello&quot;, this.uname);</code></pre><p> 4、最好在 beforeDestroy钩子中，用<strong style="color:#DD5145">$off解绑当前组件用到的自定义事件 </strong>     </p><pre><code> this.$bus.$off(&quot;hello&quot;);</code></pre><h2 id="消息订阅与发布（pubsub）"><a href="#消息订阅与发布（pubsub）" class="headerlink" title="消息订阅与发布（pubsub）"></a>消息订阅与发布（pubsub）</h2><p> 1、一种组件间通信的方式，适用于任意组件间通信<br> 2、使用步骤<br>   （1）、安装pubsub: npm i pubsub-js<br>   （2）、引入 import pubsub from “pubsub-js”;<br>    （3）、接受数据：A组件想接受数据，则在A组件中订阅消息，订阅消息的回调留在A组件自身</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">    <span class="title function_">mounted</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//订阅消息（需要数据的订阅消息，重要的是消息的内容）  （提供数据的发布消息，重要的是消息名）</span></span><br><span class="line">    <span class="comment">//这里有两个参数，magName是消息名，data是收到的数据</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">pubId</span> = pubsub.<span class="title function_">subscribe</span>(<span class="string">&quot;hello&quot;</span>, <span class="function">(<span class="params">magName, data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;有人发布了hello消息，hello消息的回调执行了&quot;</span>, data);</span><br><span class="line">    &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="string">``</span><span class="string">`    </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">4、提供数据</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    pubsub.publish(&quot;hello&quot;, 9999);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">5、最好在beforeDestroy钩子中，取消订阅 ， &lt;strong style=&quot;color:#DD5145&quot;&gt;通过id进行取消订阅操作 &lt;/strong&gt;  </span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>js</span><br><span class="line">    <span class="title function_">beforeDestroy</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//每一次订阅，消息的id都是不同的值，需要通过id取消订阅  </span></span><br><span class="line">    pubsub.<span class="title function_">unsubscribe</span>(<span class="variable language_">this</span>.<span class="property">pubId</span>);</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h2><p>1、语法：this.$nextTick(回调函数)<br>2、作用：在下一次DOM更新结束后执行其指定的回调<br>3、什么时候用：当数据改变后，要基于更新后的新DOM进行某些操作，要在nextTick所指定的回调函数中执行</p><h2 id="Vue封装的过度与动画"><a href="#Vue封装的过度与动画" class="headerlink" title="Vue封装的过度与动画"></a>Vue封装的过度与动画</h2><p>1、作用：在插入、更新或移除DOM元素时，在合适的时候给元素添加样式类名<br>2、Enter: v-enter  v-enter-active  v-enter-to<br>    Leave:v-leave   v-leave-active  v-leave-to<br>3、写法</p><pre><code>  （1）、准备好样式    元素进入的样式 enter    v-enter  进入的起点    v-enter-active  进入的过程中    v-enter-to  进入的终点  元素离开的样式 leave    v-leave  离开的起点    v-leave-active  离开的过程    v-leave-to  离开的终点</code></pre><p>   （2）、使用 transition  标签包裹要过度的元素，并配置nane属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">transition</span> <span class="attr">name</span>=<span class="string">&quot;hello&quot;</span> <span class="attr">:appear</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 如果给transition标签起名，那么下面对应的动画也要改名字   .hello-enter-active8--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-show</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span>你好啊<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>  （3）、备注<br>    若有多个元素需要过度，则需要使用  transition-group标签，并且每一个元素都有一个key值  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">transition-group</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 如果给transition标签起名，那么下面对应的动画也要改名字  .hello-enter-active8--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- transition标签里面只能由一个元素 ， 如果要给多个元素添加过度效果，需要用 transition-group 并且每一个元素都有一个唯一的key值 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-show</span>=<span class="string">&quot;isShow&quot;</span> <span class="attr">key</span>=<span class="string">&quot;1&quot;</span>&gt;</span>你好啊<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-show</span>=<span class="string">&quot;isShow&quot;</span> <span class="attr">key</span>=<span class="string">&quot;2&quot;</span>&gt;</span>bkpp<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transition-group</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="vue脚手架配置代理"><a href="#vue脚手架配置代理" class="headerlink" title="vue脚手架配置代理"></a>vue脚手架配置代理</h2><h5 id="方法一：-在vue-config-js中添加如下配置"><a href="#方法一：-在vue-config-js中添加如下配置" class="headerlink" title="方法一：  在vue.config.js中添加如下配置"></a>方法一：  在vue.config.js中添加如下配置</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line">     <span class="attr">proxy</span>: <span class="string">&#x27;http://localhost:5000&#x27;</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   说明：</span><br><span class="line">   <span class="number">1</span>、优点：配置简单，请求资源时直接发送给前端（<span class="number">8080</span>）即可</span><br><span class="line">   <span class="number">2</span>、缺点：不能配置多个代理，不能灵活的控制请求是否走代理</span><br><span class="line">   <span class="number">3</span>、工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器（优先匹配前端资源）</span><br></pre></td></tr></table></figure><h5 id="方法二：-在vue-config-js中配置具体代理规则："><a href="#方法二：-在vue-config-js中配置具体代理规则：" class="headerlink" title="方法二：   在vue.config.js中配置具体代理规则："></a>方法二：   在vue.config.js中配置具体代理规则：</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">devServer</span>: &#123;</span><br><span class="line"><span class="attr">proxy</span>: &#123;</span><br><span class="line">  <span class="string">&#x27;/api&#x27;</span>: &#123;<span class="comment">//匹配所有以 &#x27;/api&#x27; 开头的请求路径</span></span><br><span class="line">    <span class="attr">target</span>: <span class="string">&#x27;http://localhost:5000&#x27;</span>,  <span class="comment">//代理目标的基础路径</span></span><br><span class="line">    <span class="comment">//路径重写 将所有以jing开头的转换为 空  这里面要写正则表达式</span></span><br><span class="line">    <span class="attr">pathRewrite</span>: &#123; <span class="string">&#x27;^/jing&#x27;</span>: <span class="string">&#x27;&#x27;</span> &#125;,</span><br><span class="line">    <span class="attr">ws</span>: <span class="literal">true</span>,<span class="comment">//用于支持websocket</span></span><br><span class="line">    <span class="attr">changeOrigin</span>: <span class="literal">true</span><span class="comment">//用于控制请求头中的host值</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&#x27;/demo&#x27;</span>: &#123;<span class="comment">//请求前缀</span></span><br><span class="line">    <span class="attr">target</span>: <span class="string">&#x27;http://localhost:5001&#x27;</span>,</span><br><span class="line">    <span class="comment">//路径重写 将所有以jing开头的转换为 空  这里面要写正则表达式</span></span><br><span class="line">    <span class="attr">pathRewrite</span>: &#123; <span class="string">&#x27;^/demo&#x27;</span>: <span class="string">&#x27;&#x27;</span> &#125;,</span><br><span class="line">    <span class="attr">ws</span>: <span class="literal">true</span>,<span class="comment">//用于支持websocket</span></span><br><span class="line">    <span class="attr">changeOrigin</span>: <span class="literal">true</span><span class="comment">//用于控制请求头中的host值</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attr">changeOrigin</span>:设置为 <span class="literal">true</span>  服务器收到的请求头的host为 <span class="number">5000</span></span><br><span class="line"><span class="attr">changeOrigin</span>:设置为 <span class="literal">false</span>  服务器收到的请求头的host为 <span class="number">8080</span></span><br><span class="line">changeOrigin 默认为<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"><span class="number">1</span>、优点：可以配置多个代理，并且可以灵活的控制请求是否走代理</span><br><span class="line"><span class="number">2</span>、缺点：配置略微繁琐，请求资源时必须加前缀</span><br></pre></td></tr></table></figure><h2 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h2><p>1、作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于<strong style="color:#DD5145">父组件 &#x3D;&#x3D;&#x3D;&gt; 子组件 </strong><br>2、分类 ：默认插槽 、 具名插槽 、作用域插槽<br>3、使用方式<br>    （1）、默认插槽</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  父组件中</span><br><span class="line"> <span class="tag">&lt;<span class="name">Category</span> <span class="attr">title</span>=<span class="string">&quot;美食&quot;</span> <span class="attr">:list</span>=<span class="string">&quot;foods&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./assets/ppp.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">Category</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  子组件中</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;category&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; title &#125;&#125;分类<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义一个插槽（挖一个坑，等着组件的使用者来进行填充） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span>插槽，当使用者没有传具体的结构的时候，就显示这个插槽里面的东西<span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（2）、具名插槽</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">父组件中</span><br><span class="line"><span class="tag">&lt;<span class="name">Category</span> <span class="attr">title</span>=<span class="string">&quot;美食&quot;</span> <span class="attr">:list</span>=<span class="string">&quot;foods&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">slot</span>=<span class="string">&quot;center&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./assets/ppp.jpg&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">slot</span>=<span class="string">&quot;footer&quot;</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">class</span>=<span class="string">&quot;foot&quot;</span>&gt;</span>更多美食<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Category</span>&gt;</span></span><br><span class="line"></span><br><span class="line">子组件中</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;category&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; title &#125;&#125;分类<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义一个插槽（挖一个坑，等着组件的使用者来进行填充） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;center&quot;</span></span></span><br><span class="line"><span class="tag">      &gt;</span>插槽，当使用者没有传具体的结构的时候，就显示这个插槽里面的东西&lt;/slot</span><br><span class="line">    &gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;footer&quot;</span></span></span><br><span class="line"><span class="tag">      &gt;</span>插槽，当使用者没有传具体的结构的时候，就显示这个插槽里面的东西&lt;/slot</span><br><span class="line">    &gt;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（3）、作用域插槽</p><pre><code>理解：数据在组件自身，但是数据生成的结构需要组件的使用者来决定（games数据在Category组件中，但使用数据所遍历出来的结构由App组件决定）</code></pre><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">父组件中 </span><br><span class="line"> <span class="tag">&lt;<span class="name">Category</span> <span class="attr">title</span>=<span class="string">&quot;游戏&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">template</span> <span class="attr">scope</span>=<span class="string">&quot;games&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(g, index) in games.games&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span>&#123;&#123; g &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Category</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Category</span> <span class="attr">title</span>=<span class="string">&quot;游戏&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">&quot;games&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h4</span> <span class="attr">v-for</span>=<span class="string">&quot;(g, index) in games.games&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span>&#123;&#123; g &#125;&#125;<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Category</span>&gt;</span></span><br><span class="line"></span><br><span class="line">子组件中</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;category&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>&#123;&#123; title &#125;&#125;分类<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义一个插槽（挖一个坑，等着组件的使用者来进行填充） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">:games</span>=<span class="string">&quot;games&quot;</span></span></span><br><span class="line"><span class="tag">      &gt;</span>插槽，当使用者没有传具体的结构的时候，就显示这个插槽里面的东西&lt;/slot</span><br><span class="line">    &gt;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">name</span>: <span class="string">&quot;Category&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">  <span class="attr">props</span>: [<span class="string">&quot;title&quot;</span>],</span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="attr">games</span>: [<span class="string">&quot;王者荣耀&quot;</span>, <span class="string">&quot;和平精英&quot;</span>, <span class="string">&quot;蛋仔派对&quot;</span>, <span class="string">&quot;原神&quot;</span>],</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript">  &#125;,</span></span><br><span class="line"><span class="language-javascript">&#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><h4 id="安装Vuex"><a href="#安装Vuex" class="headerlink" title="安装Vuex"></a>安装Vuex</h4><pre><code>npm i vuex@3 配合vue2使用  npm i vuex@4 配合vue3使用  </code></pre><h5 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h5><p>在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中的多个组件的共享状态进行集中式的管理（读&#x2F;写），也是一种组件间同放心的方式，且适用于任意组件间通信。</p><h5 id="2、何时使用"><a href="#2、何时使用" class="headerlink" title="2、何时使用"></a>2、何时使用</h5><pre><code>多个组件需要共享数据时</code></pre><h4 id="3、搭建vuex环境"><a href="#3、搭建vuex环境" class="headerlink" title="3、搭建vuex环境"></a>3、搭建vuex环境</h4><p>1、创建文件：src&#x2F;store&#x2F;index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该文件用于创建Vuex中最为核心的store</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//引入Vue</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">//引入Vuex</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">// 使用vuex插件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>)<span class="comment">//此时vc身上就有了store这个配置项,创建Vue实例的时候就可以用store来管理actions,mutations,state</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//准备actions 用于响应组件中的动作</span></span><br><span class="line"><span class="keyword">const</span> actions = &#123;&#125;</span><br><span class="line"><span class="comment">//准备mutations  用于加工（操作）数据</span></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;&#125;</span><br><span class="line"><span class="comment">//准备state 用于存储数据</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露7store 用来管理以上三个</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">    actions,</span><br><span class="line">    mutations,</span><br><span class="line">    state,</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//导出（暴露）store</span></span><br><span class="line"><span class="comment">// export default store</span></span><br></pre></td></tr></table></figure><p>2、在main.js中创建vm时传入store配置项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//引入store</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Vue实例vm</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span><br><span class="line">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">    <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> <span class="title function_">h</span>(<span class="title class_">App</span>),</span><br><span class="line">    <span class="comment">//使用store</span></span><br><span class="line">    store,</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="4、基本使用"><a href="#4、基本使用" class="headerlink" title="4、基本使用"></a>4、基本使用</h5><p>1、初始化数据</p><pre><code>配置actions,配置mutations,操作文件store文件夹下面的index.js</code></pre><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该文件用于创建Vuex中最为核心的store</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//引入Vue</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vue</span> <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="comment">//引入Vuex</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Vuex</span> <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">// 使用vuex插件</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="title function_">use</span>(<span class="title class_">Vuex</span>)<span class="comment">//此时vc身上就有了store这个配置项,创建Vue实例的时候就可以用store来管理actions,mutations,state</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//准备actions 用于响应组件中的动作</span></span><br><span class="line"><span class="keyword">const</span> actions = &#123;</span><br><span class="line">    <span class="comment">// jia(context, value) &#123;</span></span><br><span class="line">    <span class="comment">//     console.log(&#x27;actions里面的jia被调用了&#x27;, context, value)</span></span><br><span class="line">    <span class="comment">//     context.commit(&#x27;JIA&#x27;, value)</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line">    <span class="comment">// jian(context, value) &#123;</span></span><br><span class="line">    <span class="comment">//     console.log(&#x27;actions里面的jian被调用了&#x27;, context, value)</span></span><br><span class="line">    <span class="comment">//     context.commit(&#x27;JIAN&#x27;, value)</span></span><br><span class="line">    <span class="comment">// &#125;,</span></span><br><span class="line">    <span class="title function_">jiaOdd</span>(<span class="params">context, value</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;actions里面的jiaOdd被调用了&#x27;</span>, context, value)</span><br><span class="line">        <span class="keyword">if</span> (context.<span class="property">state</span>.<span class="property">sum</span> % <span class="number">2</span>) &#123;</span><br><span class="line">            context.<span class="title function_">commit</span>(<span class="string">&#x27;JIA&#x27;</span>, value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">jiaWait</span>(<span class="params">context, value</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;actions里面的jiaWait被调用了&#x27;</span>, context, value)</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            context.<span class="title function_">commit</span>(<span class="string">&#x27;JIA&#x27;</span>, value)</span><br><span class="line">        &#125;, <span class="number">500</span>)</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//准备mutations  用于加工（操作）数据</span></span><br><span class="line"><span class="keyword">const</span> mutations = &#123;</span><br><span class="line">    <span class="title function_">JIA</span>(<span class="params">state, value</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;mutations里面的JIA被调用了&#x27;</span>, state, value)</span><br><span class="line">        state.<span class="property">sum</span> += value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">JIAN</span>(<span class="params">state, value</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;mutations里面的JIAN被调用了&#x27;</span>, state, value)</span><br><span class="line">        state.<span class="property">sum</span> -= value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//准备state 用于存储数据</span></span><br><span class="line"><span class="keyword">const</span> state = &#123;</span><br><span class="line">    <span class="attr">sum</span>: <span class="number">0</span>, <span class="comment">//当前的和</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露7store 用来管理以上三个</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">    actions,</span><br><span class="line">    mutations,</span><br><span class="line">    state,</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//导出（暴露）store</span></span><br><span class="line"><span class="comment">// export default store    </span></span><br></pre></td></tr></table></figure><p>2、组件中读取vuex中的数据</p><pre><code>    this.$store.state.sum</code></pre><p>3、组件中修改vuex中的数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&quot;action中的方法名&quot;</span>, 数据);</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&quot;mutations中的方法名&quot;</span>, 数据);</span><br><span class="line">备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写dispatch,直接写commit</span><br></pre></td></tr></table></figure><h5 id="5、getters的使用"><a href="#5、getters的使用" class="headerlink" title="5、getters的使用"></a>5、getters的使用</h5><p> 1、概念</p><pre><code>当state中的数据需要加工后在使用时，可以使用getters加工</code></pre><p> 2、在store文件中的index.js中追加配置<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//准备getters  用于将state中的数据进行加工</span></span><br><span class="line"><span class="keyword">const</span> getters = &#123;</span><br><span class="line">    <span class="title function_">bigSum</span>(<span class="params">state</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> state.<span class="property">sum</span> * <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建并暴露7store 用来管理以上三个</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">    actions,</span><br><span class="line">    mutations,</span><br><span class="line">    state,</span><br><span class="line">    getters</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><br>3、组件中读取数据</p><pre><code>$store.getters.bigSum</code></pre><h5 id="6、四个map方法的使用"><a href="#6、四个map方法的使用" class="headerlink" title="6、四个map方法的使用"></a>6、四个map方法的使用</h5><p>1、mapState方法：用于帮助我们映射state中的数据为计算属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line"> <span class="comment">//借助mapState生成计算属性，从state中读取数据（对象写法）</span></span><br><span class="line">   ...<span class="title function_">mapState</span>(&#123; <span class="attr">sum</span>: <span class="string">&quot;sum&quot;</span>, <span class="attr">school</span>: <span class="string">&quot;school&quot;</span>, <span class="attr">subject</span>: <span class="string">&quot;subject&quot;</span> &#125;),</span><br><span class="line"></span><br><span class="line">   <span class="comment">//借助mapState生成计算属性，从state中读取数据（数组写法）</span></span><br><span class="line">   ...<span class="title function_">mapState</span>([<span class="string">&quot;sum&quot;</span>, <span class="string">&quot;school&quot;</span>, <span class="string">&quot;subject&quot;</span>]),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 2、mapGetters方法：用于帮助我们映射getters中的数据为计算属性<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">computed</span>: &#123;</span><br><span class="line">  <span class="comment">// 借助mapGetters生成计算属性，从getters中读取数据（对象写法）</span></span><br><span class="line">   ...<span class="title function_">mapGetters</span>(&#123; <span class="attr">bigSum</span>: <span class="string">&quot;bigSum&quot;</span> &#125;),</span><br><span class="line">   <span class="comment">// 借助mapGetters生成计算属性，从getters中读取数据（数组写法）</span></span><br><span class="line">   ...<span class="title function_">mapGetters</span>([<span class="string">&quot;bigSum&quot;</span>]),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 3、mapActions方法：用于帮助我们生成与actions对用的方法，即：包含：$store.dispatch(xxx)函数<br> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">computed</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="title function_">computed</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="comment">//借助mapActions生成对应的方法，方法中会调用dispatch去联系actions（对象的写法）</span></span><br><span class="line">   ...<span class="title function_">mapActions</span>(&#123; <span class="attr">incrementOdd</span>: <span class="string">&quot;jiaOdd&quot;</span>, <span class="attr">incrementWait</span>: <span class="string">&quot;jiaWait&quot;</span> &#125;),</span><br><span class="line">   <span class="comment">//借助mapActions生成对应的方法，方法中会调用dispatch去联系actions（数组的写法）  对应的方法名也要变成jiaOdd  jiaWait</span></span><br><span class="line">   ...<span class="title function_">mapActions</span>([<span class="string">&quot;jiaOdd&quot;</span>, <span class="string">&quot;jiaWait&quot;</span> ]), </span><br><span class="line"> &#125;,</span><br><span class="line"> </span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><br>   4、mapMutations方法：用于帮助我们生成与mutations对用的方法，即：包含：$store.commit(xxx)函数<br>  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">computed</span>(<span class="params"></span>)&#123;</span><br><span class="line"> <span class="comment">//借助mapMutations生成对应的方法，方法中会调用commit去联系mutations（对象的写法）</span></span><br><span class="line">   ...<span class="title function_">mapMutations</span>(&#123; <span class="attr">increment</span>: <span class="string">&quot;JIA&quot;</span>, <span class="attr">decrement</span>: <span class="string">&quot;JIAN&quot;</span> &#125;),</span><br><span class="line">   <span class="comment">//借助mapMutations生成对应的方法，方法中会调用commit去联系mutations（数组的写法） 这样写了之后，对应的方法名也要变成JIA和JIAN</span></span><br><span class="line">   ...<span class="title function_">mapMutations</span>([<span class="string">&quot;JIA&quot;</span>, <span class="string">&quot;JIAN&quot;</span> ])</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><br>备注：mapActions与mapMutations使 用时，若需要传递参数需要，在模板中绑定事件时需要传递参数，否则函数就是事件对象event</p><h5 id="7、模块化-命名空间"><a href="#7、模块化-命名空间" class="headerlink" title="7、模块化+命名空间"></a>7、模块化+命名空间</h5><p>1、目的：让代码更好的维护，让多种数据分类更加明确<br>2、修改store文件夹里的index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开启了模块化编程</span></span><br><span class="line"><span class="comment">//求和相关配置 </span></span><br><span class="line"><span class="keyword">const</span> countOptions = &#123;</span><br><span class="line">    <span class="comment">//开启了模块化之后，就有了名字</span></span><br><span class="line">    <span class="attr">namespaced</span>: <span class="literal">true</span>,<span class="comment">//开启命名空间，目的就是为了让mapState认识countAbout</span></span><br><span class="line">    <span class="attr">actions</span>: &#123;</span><br><span class="line">        <span class="title function_">jiaOdd</span>(<span class="params">context, value</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;actions里面的jiaOdd被调用了&#x27;</span>, context, value)</span><br><span class="line">            <span class="keyword">if</span> (context.<span class="property">state</span>.<span class="property">sum</span> % <span class="number">2</span>) &#123;</span><br><span class="line">                context.<span class="title function_">commit</span>(<span class="string">&#x27;JIA&#x27;</span>, value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">jiaWait</span>(<span class="params">context, value</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;actions里面的jiaWait被调用了&#x27;</span>, context, value)</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                context.<span class="title function_">commit</span>(<span class="string">&#x27;JIA&#x27;</span>, value)</span><br><span class="line">            &#125;, <span class="number">500</span>)</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">mutations</span>: &#123;</span><br><span class="line">        <span class="title function_">JIA</span>(<span class="params">state, value</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;mutations里面的JIA被调用了&#x27;</span>, state, value)</span><br><span class="line">            state.<span class="property">sum</span> += value</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="title function_">JIAN</span>(<span class="params">state, value</span>) &#123;<span class="comment">//这里的value就是要加的数字</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;mutations里面的JIAN被调用了&#x27;</span>, state, value)</span><br><span class="line">            state.<span class="property">sum</span> -= value</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">state</span>: &#123;</span><br><span class="line">        <span class="attr">sum</span>: <span class="number">0</span>, <span class="comment">//当前的和</span></span><br><span class="line">        <span class="attr">school</span>: <span class="string">&#x27;bilibili&#x27;</span>,</span><br><span class="line">        <span class="attr">subject</span>: <span class="string">&#x27;前端&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">getters</span>: &#123;</span><br><span class="line">        <span class="title function_">bigSum</span>(<span class="params">state</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> state.<span class="property">sum</span> * <span class="number">10</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//人员管理相关配置</span></span><br><span class="line"><span class="keyword">const</span> personOptions = &#123;</span><br><span class="line">    <span class="attr">namespaced</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">actions</span>: &#123;</span><br><span class="line">        <span class="comment">//添加一个姓王的人</span></span><br><span class="line">        <span class="title function_">addPersonWang</span>(<span class="params">context, value</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value.<span class="property">name</span>.<span class="title function_">indexOf</span>(<span class="string">&#x27;王&#x27;</span>) === <span class="number">0</span>) &#123;</span><br><span class="line">                context.<span class="title function_">commit</span>(<span class="string">&#x27;ADD_PERSON&#x27;</span>, value)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="title function_">alert</span>(<span class="string">&#x27;输入的人不姓王！&#x27;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//找服务器要一个东西</span></span><br><span class="line">        <span class="title function_">addPersonServe</span>(<span class="params">context</span>) &#123;</span><br><span class="line">            axios.<span class="title function_">get</span>(<span class="string">&#x27;https://api.uixsj.cn/hitokoto/get?type=social&#x27;</span>).<span class="title function_">then</span>(</span><br><span class="line">                <span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">                    context.<span class="title function_">commit</span>(<span class="string">&#x27;ADD_PERSON&#x27;</span>, &#123; <span class="attr">id</span>: <span class="title function_">nanoid</span>(), <span class="attr">name</span>: response.<span class="property">data</span> &#125;)</span><br><span class="line">                &#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">                    <span class="title function_">alert</span>(error.<span class="property">message</span>)</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">mutations</span>: &#123;</span><br><span class="line">        <span class="title function_">ADD_PERSON</span>(<span class="params">state, value</span>) &#123;<span class="comment">//这里的value就是输入的人名的那个对象</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;mutations里面的JIAN被调用了&#x27;</span>, state, value)</span><br><span class="line">            state.<span class="property">personList</span>.<span class="title function_">unshift</span>(value)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">state</span>: &#123;</span><br><span class="line">        <span class="attr">personList</span>: [&#123;</span><br><span class="line">            <span class="attr">id</span>: <span class="string">&#x27;001&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;静香&#x27;</span></span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">getters</span>: &#123;</span><br><span class="line">        <span class="comment">//这里的state是 当前Person组件的state</span></span><br><span class="line">        <span class="title function_">firstPersonName</span>(<span class="params">state</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> state.<span class="property">personList</span>[<span class="number">0</span>].<span class="property">name</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//创建并暴露7store 用来管理以上三个</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">Vuex</span>.<span class="title class_">Store</span>(&#123;</span><br><span class="line">    <span class="attr">modules</span>: &#123;</span><br><span class="line">        <span class="attr">countAbout</span>: countOptions,</span><br><span class="line">        <span class="attr">personAbout</span>: personOptions</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>3、开启命名空间后，组件中读取state数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一：自己直接读取</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">state</span>.<span class="property">personAbout</span>.<span class="property">personList</span>;</span><br><span class="line"><span class="comment">// 方式二：借助mapState读取</span></span><br><span class="line">...<span class="title function_">mapState</span>(<span class="string">&quot;countAbout&quot;</span>, [<span class="string">&quot;sum&quot;</span>, <span class="string">&quot;school&quot;</span>, <span class="string">&quot;subject&quot;</span>], <span class="string">&quot;personAbout&quot;</span>, [</span><br><span class="line">      <span class="string">&quot;personList&quot;</span>,</span><br><span class="line">    ]),</span><br></pre></td></tr></table></figure><p>4、开启命名空间后，组件中读取getters数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一：自己直接读取</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="property">getters</span>[<span class="string">&quot;personAbout/firstPersonName&quot;</span>];</span><br><span class="line"><span class="comment">// 方式二：借助mapGetters读取</span></span><br><span class="line">...<span class="title function_">mapGetters</span>(<span class="string">&quot;countAbout&quot;</span>, [<span class="string">&quot;bigSum&quot;</span>]),</span><br></pre></td></tr></table></figure><p>5、开启命名空间后，组件中调用dispatch</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一：自己直接读取</span></span><br><span class="line"> <span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&quot;personAbout/addPersonWang&quot;</span>, personObj);</span><br><span class="line"><span class="comment">// 方式二：借助mapActions读取</span></span><br><span class="line">    ...<span class="title function_">mapActions</span>(<span class="string">&quot;countAbout&quot;</span>, &#123;</span><br><span class="line">      <span class="attr">incrementOdd</span>: <span class="string">&quot;jiaOdd&quot;</span>,</span><br><span class="line">      <span class="attr">incrementWait</span>: <span class="string">&quot;jiaWait&quot;</span>,</span><br><span class="line">    &#125;),</span><br></pre></td></tr></table></figure><p>6、开启命名空间后，组件中调用commit</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式一：自己直接读取</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">commit</span>(<span class="string">&quot;personAbout/ADD_PERSON&quot;</span>, personObj);</span><br><span class="line"><span class="comment">// 方式二：借助mapMutations读取</span></span><br><span class="line">    ...<span class="title function_">mapMutations</span>(<span class="string">&quot;countAbout&quot;</span>, &#123; <span class="attr">increment</span>: <span class="string">&quot;JIA&quot;</span>, <span class="attr">decrement</span>: <span class="string">&quot;JIAN&quot;</span> &#125;),</span><br></pre></td></tr></table></figure><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>1、理解：一个路由（route），就是一组映射关系（key-value）,多个路由需要路由器（router）进行管理。<br>2、前端路由：key是路径，value是组件</p><h5 id="1、基本使用"><a href="#1、基本使用" class="headerlink" title="1、基本使用"></a>1、基本使用</h5><p>1、安装vue-router</p><pre><code>  npm i vue-router@3  用于vue2   npm i vue-router@4  用于vue3</code></pre><p>2、应用插件</p><pre><code> Vue.use(VueRouter)</code></pre><p>3、编写router配置项（新建router文件夹 index.js文件）  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个配置器（里面写的就是各种路由）</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">VueRouter</span> <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"><span class="comment">//引入组件</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">About</span> <span class="keyword">from</span> <span class="string">&#x27;../components/About&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Home</span> <span class="keyword">from</span> <span class="string">&#x27;../components/Home&#x27;</span></span><br><span class="line"><span class="comment">//创建并暴露一个路由器</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">    <span class="attr">routes</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>: <span class="title class_">About</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>: <span class="title class_">Home</span></span><br><span class="line">        &#125;]</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>4、实现切换（active-class可配置高亮样式）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link <span class="keyword">class</span>=<span class="string">&quot;list-group-item&quot;</span> active-<span class="keyword">class</span>=<span class="string">&quot;active&quot;</span> to=<span class="string">&quot;/about&quot;</span></span><br><span class="line">        &gt;<span class="title class_">About</span>&lt;/router-link</span><br></pre></td></tr></table></figure><p>5、指定展示位置</p><pre><code>&lt;router-view&gt;&lt;/router-view&gt;</code></pre><h5 id="2、几个注意点"><a href="#2、几个注意点" class="headerlink" title="2、几个注意点"></a>2、几个注意点</h5><p>1、路由组件通常存放在pages文件夹中，一般组件通常存放在components文件夹。<br>2、通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。<br>3、每个组件都有自己的$route属性，里面存储着自己的路由信息。<br>4、整个应用只有一个router，可以通过组件的$router属性获取到。</p><h5 id="3、路由嵌套（多级路由）"><a href="#3、路由嵌套（多级路由）" class="headerlink" title="3、路由嵌套（多级路由）"></a>3、路由嵌套（多级路由）</h5><p>1、配置路由规则，使用children配置项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建并暴露一个路由器</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">    <span class="attr">routes</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>: <span class="title class_">About</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>: <span class="title class_">Home</span>,</span><br><span class="line">            <span class="attr">children</span>: [&#123;</span><br><span class="line">                <span class="attr">path</span>: <span class="string">&#x27;news&#x27;</span>,</span><br><span class="line">                <span class="attr">component</span>: <span class="title class_">News</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">path</span>: <span class="string">&#x27;message&#x27;</span>,</span><br><span class="line">                <span class="attr">component</span>: <span class="title class_">Message</span></span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;]</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>2、跳转（要写完整的路径）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;router-link <span class="keyword">class</span>=<span class="string">&quot;list-group-item&quot;</span> active-<span class="keyword">class</span>=<span class="string">&quot;active&quot;</span> to=<span class="string">&quot;/home/news&quot;</span>&gt;<span class="title class_">News</span>&lt;/router-link&gt;</span><br></pre></td></tr></table></figure><h5 id="4、路由的query参数"><a href="#4、路由的query参数" class="headerlink" title="4、路由的query参数"></a>4、路由的query参数</h5><p>1、传递参数</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 跳转路由并携带query参数， to的字符串写法 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;router-link :to=&quot;`/home/message/detail?id=$&#123;m.id&#125;&amp;title=$&#123;m.title&#125;`&quot;</span></span><br><span class="line"><span class="comment">          &gt;message001&lt;/router-link</span></span><br><span class="line"><span class="comment">        &gt;&amp;nbsp;&amp;nbsp; --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 跳转路由并携带query参数， to的对象写法 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">router-link</span></span></span><br><span class="line"><span class="tag">          <span class="attr">:to</span>=<span class="string">&quot;&#123;</span></span></span><br><span class="line"><span class="string"><span class="tag">            path: &#x27;/home/message/detail&#x27;,</span></span></span><br><span class="line"><span class="string"><span class="tag">            query: &#123;</span></span></span><br><span class="line"><span class="string"><span class="tag">              id: 666,</span></span></span><br><span class="line"><span class="string"><span class="tag">              title: 哈哈哈,</span></span></span><br><span class="line"><span class="string"><span class="tag">            &#125;,</span></span></span><br><span class="line"><span class="string"><span class="tag">          &#125;&quot;</span></span></span><br><span class="line"><span class="tag">          &gt;</span>跳转&lt;/router-link</span><br><span class="line">        &gt;</span><br></pre></td></tr></table></figure><p> 2、接收参数</p><pre><code>  $route.query.id   $route.query.title</code></pre><h5 id="5、命名路由"><a href="#5、命名路由" class="headerlink" title="5、命名路由"></a>5、命名路由</h5><p>1、作用：可以简化路由的跳转<br>2、如何使用<br>（1）、给路由命名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建并暴露一个路由器</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">    <span class="attr">routes</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;guanyu&#x27;</span>,<span class="comment">//给路由命名</span></span><br><span class="line">            <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>: <span class="title class_">About</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>: <span class="title class_">Home</span>,</span><br><span class="line">            <span class="attr">children</span>: [&#123;</span><br><span class="line">                <span class="attr">path</span>: <span class="string">&#x27;news&#x27;</span>,</span><br><span class="line">                <span class="attr">component</span>: <span class="title class_">News</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">name</span>: <span class="string">&#x27;xiaoxi&#x27;</span>,</span><br><span class="line">                <span class="attr">path</span>: <span class="string">&#x27;message&#x27;</span>,</span><br><span class="line">                <span class="attr">component</span>: <span class="title class_">Message</span>,</span><br><span class="line">                <span class="attr">children</span>: [&#123;</span><br><span class="line">                    <span class="attr">name</span>: <span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line">                    <span class="attr">path</span>: <span class="string">&#x27;detail&#x27;</span>,</span><br><span class="line">                    <span class="attr">component</span>: <span class="title class_">Detail</span></span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;]</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>（2）、简化跳转</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 简化后，通过路由的名字进行跳转 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">router-link</span></span></span><br><span class="line"><span class="tag">            <span class="attr">class</span>=<span class="string">&quot;list-group-item&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">active-class</span>=<span class="string">&quot;active&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">:to</span>=<span class="string">&quot;&#123; name: &#x27;guanyu&#x27; &#125;&quot;</span></span></span><br><span class="line"><span class="tag">            &gt;</span>About&lt;/router-link</span><br><span class="line">          &gt;</span><br><span class="line">          <span class="comment">&lt;!-- 简化前需要写完整的路径 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">class</span>=<span class="string">&quot;list-group-item&quot;</span> <span class="attr">active-class</span>=<span class="string">&quot;active&quot;</span> <span class="attr">to</span>=<span class="string">&quot;/home&quot;</span></span></span><br><span class="line"><span class="tag">            &gt;</span>Home&lt;/router-link</span><br><span class="line">          &gt;</span><br><span class="line">```    </span><br><span class="line">##### 6、路由的params参数</span><br><span class="line">1、配置路由，声明接受params参数    </span><br><span class="line">```js</span><br><span class="line">//创建并暴露一个路由器</span><br><span class="line">export default new VueRouter(&#123;</span><br><span class="line">    routes: [</span><br><span class="line">        &#123;</span><br><span class="line">            name: &#x27;guanyu&#x27;,//给路由命名</span><br><span class="line">            path: &#x27;/about&#x27;,</span><br><span class="line">            component: About</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            path: &#x27;/home&#x27;,</span><br><span class="line">            component: Home,</span><br><span class="line">            children: [&#123;</span><br><span class="line">                path: &#x27;news&#x27;,</span><br><span class="line">                component: News</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                name: &#x27;xiaoxi&#x27;,</span><br><span class="line">                path: &#x27;message&#x27;,</span><br><span class="line">                component: Message,</span><br><span class="line">                children: [&#123;</span><br><span class="line">                    name: &#x27;xiangqing&#x27;,</span><br><span class="line">                    path: &#x27;detail/:id/:title&#x27;,//使用占位符声明接受params参数</span><br><span class="line">                    component: Detail</span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;]</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>2、传递参数</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 跳转路由并携带params参数， to的字符串写法 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;`/home/message/detail/$&#123;m.id&#125;/$&#123;m.title&#125;`&quot;</span>&gt;</span>&#123;&#123;</span><br><span class="line">          m.title</span><br><span class="line">        &#125;&#125;&lt;/router-link</span><br><span class="line">        &gt;<span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span></span><br><span class="line"><span class="comment">&lt;!-- 跳转路由并携带params参数， to的对象写法,这种写法只能使用命名路由 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">router-link</span></span></span><br><span class="line"><span class="tag">          <span class="attr">:to</span>=<span class="string">&quot;&#123;</span></span></span><br><span class="line"><span class="string"><span class="tag">            name: &#x27;xiangqing&#x27;,</span></span></span><br><span class="line"><span class="string"><span class="tag">            params: &#123;</span></span></span><br><span class="line"><span class="string"><span class="tag">              id: m.id,</span></span></span><br><span class="line"><span class="string"><span class="tag">              title: m.title,</span></span></span><br><span class="line"><span class="string"><span class="tag">            &#125;,</span></span></span><br><span class="line"><span class="string"><span class="tag">          &#125;&quot;</span></span></span><br><span class="line"><span class="tag">          &gt;</span>&#123;&#123; m.title &#125;&#125;&lt;/router-link</span><br><span class="line">        &gt;<span class="symbol">&amp;nbsp;</span><span class="symbol">&amp;nbsp;</span></span><br></pre></td></tr></table></figure><pre><code>特别注意：路由携带params参数时，若使用to对象写法，则不能使用path配置项，必须使用name配置</code></pre><p>3、接受参数</p><pre><code>$route.params.id $route.params.title</code></pre><h5 id="7、路由的props配置"><a href="#7、路由的props配置" class="headerlink" title="7、路由的props配置"></a>7、路由的props配置</h5><p>作用：让路由组件更方便接收到参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建并暴露一个路由器</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> <span class="title class_">VueRouter</span>(&#123;</span><br><span class="line">    <span class="attr">routes</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;guanyu&#x27;</span>,<span class="comment">//给路由命名</span></span><br><span class="line">            <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>: <span class="title class_">About</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">            <span class="attr">component</span>: <span class="title class_">Home</span>,</span><br><span class="line">            <span class="attr">children</span>: [&#123;</span><br><span class="line">                <span class="attr">path</span>: <span class="string">&#x27;news&#x27;</span>,</span><br><span class="line">                <span class="attr">component</span>: <span class="title class_">News</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">name</span>: <span class="string">&#x27;xiaoxi&#x27;</span>,</span><br><span class="line">                <span class="attr">path</span>: <span class="string">&#x27;message&#x27;</span>,</span><br><span class="line">                <span class="attr">component</span>: <span class="title class_">Message</span>,</span><br><span class="line">                <span class="attr">children</span>: [&#123;</span><br><span class="line">                    <span class="attr">name</span>: <span class="string">&#x27;xiangqing&#x27;</span>,</span><br><span class="line">                    <span class="attr">path</span>: <span class="string">&#x27;detail&#x27;</span>,<span class="comment">//使用占位符声明接受params参数</span></span><br><span class="line">                    <span class="attr">component</span>: <span class="title class_">Detail</span>,</span><br><span class="line">                    <span class="comment">//第一种写法，props的值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件</span></span><br><span class="line">                    <span class="comment">// props: &#123; id: &#x27;666&#x27;, title: &#x27;hello&#x27; &#125;</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//第二种写法，props的值为布尔值true，则会把路由收到的所有parmas参数通过props传给Detail组件</span></span><br><span class="line">                    <span class="comment">// props: true,</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//第三种写法，props的值为函数，该函数返回的对象中的每一组key-value都会通过props传给Detail组件</span></span><br><span class="line">                    <span class="title function_">props</span>(<span class="params">$route</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> &#123;</span><br><span class="line">                            <span class="attr">id</span>: $route.<span class="property">query</span>.<span class="property">id</span>,</span><br><span class="line">                            <span class="attr">title</span>: $route.<span class="property">query</span>.<span class="property">title</span>,</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;]</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="8、router-link标签的replace属性"><a href="#8、router-link标签的replace属性" class="headerlink" title="8、router-link标签的replace属性"></a>8、router-link标签的replace属性</h5><p>1、作用：控制路由跳转时操作浏览器历史记录模式<br>2、浏览器的历史纪录有两种写入方式，分别为：push和replace,push是追加历史记录，replace是替换当前记录，路由跳转的时候默认为true.<br>3、如何开启replace模式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">      <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">replace</span>&gt;</span>About<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">```      </span><br><span class="line">##### 9、编程式路由导航</span><br><span class="line">1、作用：不借助router-link标签实现路由跳转，可让路由跳转更加灵活</span><br><span class="line">2、具体编码</span><br><span class="line">```js</span><br><span class="line">// $router的两个API</span><br><span class="line"> this.$router.push(&#123;</span><br><span class="line">        name: &quot;xiangqing&quot;,</span><br><span class="line">        query: &#123;</span><br><span class="line">          id: m.id,</span><br><span class="line">          title: m.title,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">   this.$router.replace(&#123;</span><br><span class="line">        name: &quot;xiangqing&quot;,</span><br><span class="line">        query: &#123;</span><br><span class="line">          id: m.id,</span><br><span class="line">          title: m.title,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line"> this.$router.back();   //后退</span><br><span class="line"> this.$router.forward(); //前进</span><br><span class="line">this.$router.go(2); //里面的参数正数表示前进，负数表示后退     </span><br></pre></td></tr></table></figure><h5 id="10、缓存路由组件"><a href="#10、缓存路由组件" class="headerlink" title="10、缓存路由组件"></a>10、缓存路由组件</h5><p>1、作用：让不展示的路由组件保持挂载，不被销毁<br>2、具体编码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 保持组件活跃，跳转路由后，不被销毁   include里面写的是不被销毁的组件--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">include</span>=<span class="string">&quot;News&quot;</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">ke-alive</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="11、两个新的生命周期钩子"><a href="#11、两个新的生命周期钩子" class="headerlink" title="11、两个新的生命周期钩子"></a>11、两个新的生命周期钩子</h5><p>1、作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态<br>2、具体名字:</p><pre><code>（1）、activated路由组件被激活时触发（2）、deactivated路由组件失活时触发</code></pre><h5 id="12、路由守卫"><a href="#12、路由守卫" class="headerlink" title="12、路由守卫"></a>12、路由守卫</h5><p>1、作用：对路由进行权限控制<br>2、分类：全局守卫、独享守卫、组件内守卫<br>3、全局守卫</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局前置路由守卫——初始化的时候被调用，每次路由切换路由之前被调用</span></span><br><span class="line">router.<span class="title function_">beforeEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;前置路由守卫&#x27;</span>, to, <span class="keyword">from</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (to.<span class="property">meta</span>.<span class="property">isAuth</span>) &#123;<span class="comment">//判断当前路由是否需要鉴定权限</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;school&#x27;</span>) === <span class="string">&#x27;bilibili&#x27;</span>) &#123;</span><br><span class="line">            <span class="title function_">next</span>()<span class="comment">//放行</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_">alert</span>(<span class="string">&#x27;学校名不对，无权限查看&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">next</span>()<span class="comment">//放行</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//全局后置路由守卫——初始化的时候被调用，每次切换路由之后被调用（无next()）</span></span><br><span class="line">router.<span class="title function_">afterEach</span>(<span class="function">(<span class="params">to, <span class="keyword">from</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;后置路由守卫&#x27;</span>, to, <span class="keyword">from</span>)</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">title</span> = to.<span class="property">meta</span>.<span class="property">title</span> || <span class="string">&#x27;lalal&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>4、独享路由守卫（就是某一个路由的）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">beforeEnter</span>: <span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;<span class="comment">//独享路由守卫 （只有前置，没有后置）</span></span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;前置路由守卫&#x27;</span>, to, <span class="keyword">from</span>)</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (to.<span class="property">meta</span>.<span class="property">isAuth</span>) &#123;<span class="comment">//判断是否需要鉴定权限</span></span><br><span class="line">                        <span class="keyword">if</span> (<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&#x27;school&#x27;</span>) === <span class="string">&#x27;bilibili&#x27;</span>) &#123;</span><br><span class="line">                            <span class="title function_">next</span>()</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="title function_">alert</span>(<span class="string">&#x27;学校名不对，无权限查看&#x27;</span>)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="title function_">next</span>()</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><p>5、组件内守卫</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过路由规则进入该组件时被调用</span></span><br><span class="line"><span class="title function_">beforeRouteEnter</span>(<span class="params">to, <span class="keyword">from</span>, next</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;组件内路由守卫&quot;</span>, to, <span class="keyword">from</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (to.<span class="property">meta</span>.<span class="property">isAuth</span>) &#123;</span><br><span class="line">    <span class="comment">//判断是否需要鉴定权限</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">localStorage</span>.<span class="title function_">getItem</span>(<span class="string">&quot;school&quot;</span>) === <span class="string">&quot;bilibili&quot;</span>) &#123;</span><br><span class="line">      <span class="title function_">next</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="title function_">alert</span>(<span class="string">&quot;学校名不对，无权限查看&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="title function_">next</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="comment">//通过路由规则离开该组件时被调用</span></span><br><span class="line"><span class="title function_">beforeRouteLeave</span>(<span class="params">to, <span class="keyword">from</span>, next</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;组件内路由守卫&quot;</span>, to, <span class="keyword">from</span>);</span><br><span class="line">  <span class="title function_">next</span>();</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h5 id="13、路由器的两种工作模式"><a href="#13、路由器的两种工作模式" class="headerlink" title="13、路由器的两种工作模式"></a>13、路由器的两种工作模式</h5><p>  1、对于一个url来说，什么是hash值？ ——#及其后面的内容就是hash值。<br>  2、hash值不会包含在HTTP请求中，即：hash值不会带给服务器<br>  3、hash模式</p><pre><code> 1、地址中永远带着#号，不美观。 2、若以后将地址通过第三方手机app分享，若app校验严格，则地址会标记为不合格。 3、兼容性较好</code></pre><p>  4、history模式</p><pre><code> 1、地址干净、美观。 2、兼容性和hash模式相比较差。 3、应用部署上线需要后端人员支持，解决刷新页面服务器中404的问题。                    </code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>node.js</title>
      <link href="/2022/12/02/nodejs/"/>
      <url>/2022/12/02/nodejs/</url>
      
        <content type="html"><![CDATA[<h2 id="jing的哈哈哈"><a href="#jing的哈哈哈" class="headerlink" title="jing的哈哈哈"></a>jing的哈哈哈</h2><h3 id="node"><a href="#node" class="headerlink" title="node"></a>node</h3><blockquote><h2 id="ref属性"><a href="#ref属性" class="headerlink" title="ref属性"></a>ref属性</h2><p>1、被用来给元素或子组件注册引用信息<br>2、应用在html标签上获取的是真实的DOM元素，应用在子组件标签上获取的是组件实例对象 vc<br>3、使用方式</p><blockquote><ul><li>打标识:<br> <code>&lt;h1 v-text=&quot;msg&quot; ref=&quot;title&quot;&gt;xxx&lt;/h1&gt;</code><br>   <code>&lt;School ref=&quot;sch&quot; /&gt;</code></li><li>获取：<blockquote><ul><li>console.log(this.$refs.title);  真实的DOM元素 </li><li>console.log(this.$refs.sch);  School组件的实例对象 vc</li></ul></blockquote></li></ul></blockquote></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>jing的第一篇文章</title>
      <link href="/2022/11/30/22-11-30-jing%E7%9A%84%E7%AC%AC%E4%B8%80%E7%89%87%E6%96%87%E7%AB%A0/"/>
      <url>/2022/11/30/22-11-30-jing%E7%9A%84%E7%AC%AC%E4%B8%80%E7%89%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="jing的哈哈哈"><a href="#jing的哈哈哈" class="headerlink" title="jing的哈哈哈"></a>jing的哈哈哈</h2>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
